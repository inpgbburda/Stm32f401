/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "task.h"

static const char* CMockString_eAction = "eAction";
static const char* CMockString_eState = "eState";
static const char* CMockString_eTaskConfirmSleepModeStatus = "eTaskConfirmSleepModeStatus";
static const char* CMockString_eTaskGetState = "eTaskGetState";
static const char* CMockString_lExternalKernelObjectHandle = "lExternalKernelObjectHandle";
static const char* CMockString_lInternalIndexOfKernelObject = "lInternalIndexOfKernelObject";
static const char* CMockString_pcName = "pcName";
static const char* CMockString_pcNameToQuery = "pcNameToQuery";
static const char* CMockString_pcTaskGetName = "pcTaskGetName";
static const char* CMockString_pcTaskName = "pcTaskName";
static const char* CMockString_pcWriteBuffer = "pcWriteBuffer";
static const char* CMockString_ppuxStackBuffer = "ppuxStackBuffer";
static const char* CMockString_ppxIdleTaskStackBuffer = "ppxIdleTaskStackBuffer";
static const char* CMockString_ppxIdleTaskTCBBuffer = "ppxIdleTaskTCBBuffer";
static const char* CMockString_ppxTaskBuffer = "ppxTaskBuffer";
static const char* CMockString_pulNotificationValue = "pulNotificationValue";
static const char* CMockString_pulPreviousNotificationValue = "pulPreviousNotificationValue";
static const char* CMockString_pulTotalRunTime = "pulTotalRunTime";
static const char* CMockString_puxIdleTaskStackSize = "puxIdleTaskStackSize";
static const char* CMockString_puxStackBuffer = "puxStackBuffer";
static const char* CMockString_pvParameter = "pvParameter";
static const char* CMockString_pvParameters = "pvParameters";
static const char* CMockString_pvTaskGetThreadLocalStoragePointer = "pvTaskGetThreadLocalStoragePointer";
static const char* CMockString_pvTaskIncrementMutexHeldCount = "pvTaskIncrementMutexHeldCount";
static const char* CMockString_pvValue = "pvValue";
static const char* CMockString_pxCreatedTask = "pxCreatedTask";
static const char* CMockString_pxEventList = "pxEventList";
static const char* CMockString_pxEventListItem = "pxEventListItem";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxHookFunction = "pxHookFunction";
static const char* CMockString_pxMutexHolder = "pxMutexHolder";
static const char* CMockString_pxPreviousWakeTime = "pxPreviousWakeTime";
static const char* CMockString_pxRegions = "pxRegions";
static const char* CMockString_pxTaskBuffer = "pxTaskBuffer";
static const char* CMockString_pxTaskCode = "pxTaskCode";
static const char* CMockString_pxTaskDefinition = "pxTaskDefinition";
static const char* CMockString_pxTaskStatus = "pxTaskStatus";
static const char* CMockString_pxTaskStatusArray = "pxTaskStatusArray";
static const char* CMockString_pxTicksToWait = "pxTicksToWait";
static const char* CMockString_pxTimeOut = "pxTimeOut";
static const char* CMockString_ulBitsToClear = "ulBitsToClear";
static const char* CMockString_ulBitsToClearOnEntry = "ulBitsToClearOnEntry";
static const char* CMockString_ulBitsToClearOnExit = "ulBitsToClearOnExit";
static const char* CMockString_ulTaskGenericNotifyTake = "ulTaskGenericNotifyTake";
static const char* CMockString_ulTaskGenericNotifyValueClear = "ulTaskGenericNotifyValueClear";
static const char* CMockString_ulTaskGetIdleRunTimeCounter = "ulTaskGetIdleRunTimeCounter";
static const char* CMockString_ulTaskGetIdleRunTimePercent = "ulTaskGetIdleRunTimePercent";
static const char* CMockString_ulTaskGetRunTimeCounter = "ulTaskGetRunTimeCounter";
static const char* CMockString_ulTaskGetRunTimePercent = "ulTaskGetRunTimePercent";
static const char* CMockString_ulValue = "ulValue";
static const char* CMockString_uxArraySize = "uxArraySize";
static const char* CMockString_uxBufferLength = "uxBufferLength";
static const char* CMockString_uxCoreAffinityMask = "uxCoreAffinityMask";
static const char* CMockString_uxHandle = "uxHandle";
static const char* CMockString_uxHighestPriorityWaitingTask = "uxHighestPriorityWaitingTask";
static const char* CMockString_uxIndexToClear = "uxIndexToClear";
static const char* CMockString_uxIndexToNotify = "uxIndexToNotify";
static const char* CMockString_uxIndexToWaitOn = "uxIndexToWaitOn";
static const char* CMockString_uxNewPriority = "uxNewPriority";
static const char* CMockString_uxPriority = "uxPriority";
static const char* CMockString_uxSavedInterruptStatus = "uxSavedInterruptStatus";
static const char* CMockString_uxStackDepth = "uxStackDepth";
static const char* CMockString_uxTaskBasePriorityGet = "uxTaskBasePriorityGet";
static const char* CMockString_uxTaskBasePriorityGetFromISR = "uxTaskBasePriorityGetFromISR";
static const char* CMockString_uxTaskGetNumberOfTasks = "uxTaskGetNumberOfTasks";
static const char* CMockString_uxTaskGetStackHighWaterMark = "uxTaskGetStackHighWaterMark";
static const char* CMockString_uxTaskGetStackHighWaterMark2 = "uxTaskGetStackHighWaterMark2";
static const char* CMockString_uxTaskGetSystemState = "uxTaskGetSystemState";
static const char* CMockString_uxTaskGetTaskNumber = "uxTaskGetTaskNumber";
static const char* CMockString_uxTaskPriorityGet = "uxTaskPriorityGet";
static const char* CMockString_uxTaskPriorityGetFromISR = "uxTaskPriorityGetFromISR";
static const char* CMockString_uxTaskResetEventItemValue = "uxTaskResetEventItemValue";
static const char* CMockString_vApplicationGetIdleTaskMemory = "vApplicationGetIdleTaskMemory";
static const char* CMockString_vApplicationGetPassiveIdleTaskMemory = "vApplicationGetPassiveIdleTaskMemory";
static const char* CMockString_vApplicationIdleHook = "vApplicationIdleHook";
static const char* CMockString_vApplicationStackOverflowHook = "vApplicationStackOverflowHook";
static const char* CMockString_vApplicationTickHook = "vApplicationTickHook";
static const char* CMockString_vGrantAccessToKernelObject = "vGrantAccessToKernelObject";
static const char* CMockString_vPortGrantAccessToKernelObject = "vPortGrantAccessToKernelObject";
static const char* CMockString_vPortRevokeAccessToKernelObject = "vPortRevokeAccessToKernelObject";
static const char* CMockString_vRevokeAccessToKernelObject = "vRevokeAccessToKernelObject";
static const char* CMockString_vTaskAllocateMPURegions = "vTaskAllocateMPURegions";
static const char* CMockString_vTaskCoreAffinityGet = "vTaskCoreAffinityGet";
static const char* CMockString_vTaskCoreAffinitySet = "vTaskCoreAffinitySet";
static const char* CMockString_vTaskDelay = "vTaskDelay";
static const char* CMockString_vTaskDelete = "vTaskDelete";
static const char* CMockString_vTaskEndScheduler = "vTaskEndScheduler";
static const char* CMockString_vTaskEnterCritical = "vTaskEnterCritical";
static const char* CMockString_vTaskEnterCriticalFromISR = "vTaskEnterCriticalFromISR";
static const char* CMockString_vTaskExitCritical = "vTaskExitCritical";
static const char* CMockString_vTaskExitCriticalFromISR = "vTaskExitCriticalFromISR";
static const char* CMockString_vTaskGenericNotifyGiveFromISR = "vTaskGenericNotifyGiveFromISR";
static const char* CMockString_vTaskGetInfo = "vTaskGetInfo";
static const char* CMockString_vTaskGetRunTimeStatistics = "vTaskGetRunTimeStatistics";
static const char* CMockString_vTaskInternalSetTimeOutState = "vTaskInternalSetTimeOutState";
static const char* CMockString_vTaskListTasks = "vTaskListTasks";
static const char* CMockString_vTaskMissedYield = "vTaskMissedYield";
static const char* CMockString_vTaskPlaceOnEventList = "vTaskPlaceOnEventList";
static const char* CMockString_vTaskPlaceOnEventListRestricted = "vTaskPlaceOnEventListRestricted";
static const char* CMockString_vTaskPlaceOnUnorderedEventList = "vTaskPlaceOnUnorderedEventList";
static const char* CMockString_vTaskPreemptionDisable = "vTaskPreemptionDisable";
static const char* CMockString_vTaskPreemptionEnable = "vTaskPreemptionEnable";
static const char* CMockString_vTaskPriorityDisinheritAfterTimeout = "vTaskPriorityDisinheritAfterTimeout";
static const char* CMockString_vTaskPrioritySet = "vTaskPrioritySet";
static const char* CMockString_vTaskRemoveFromUnorderedEventList = "vTaskRemoveFromUnorderedEventList";
static const char* CMockString_vTaskResetState = "vTaskResetState";
static const char* CMockString_vTaskResume = "vTaskResume";
static const char* CMockString_vTaskSetApplicationTaskTag = "vTaskSetApplicationTaskTag";
static const char* CMockString_vTaskSetTaskNumber = "vTaskSetTaskNumber";
static const char* CMockString_vTaskSetThreadLocalStoragePointer = "vTaskSetThreadLocalStoragePointer";
static const char* CMockString_vTaskSetTimeOutState = "vTaskSetTimeOutState";
static const char* CMockString_vTaskStartScheduler = "vTaskStartScheduler";
static const char* CMockString_vTaskStepTick = "vTaskStepTick";
static const char* CMockString_vTaskSuspend = "vTaskSuspend";
static const char* CMockString_vTaskSuspendAll = "vTaskSuspendAll";
static const char* CMockString_vTaskSwitchContext = "vTaskSwitchContext";
static const char* CMockString_vTaskYieldWithinAPI = "vTaskYieldWithinAPI";
static const char* CMockString_xClearCountOnExit = "xClearCountOnExit";
static const char* CMockString_xCoreID = "xCoreID";
static const char* CMockString_xExternalTaskHandle = "xExternalTaskHandle";
static const char* CMockString_xGetFreeStackSpace = "xGetFreeStackSpace";
static const char* CMockString_xIndex = "xIndex";
static const char* CMockString_xInternalTaskHandle = "xInternalTaskHandle";
static const char* CMockString_xItemValue = "xItemValue";
static const char* CMockString_xPassiveIdleTaskIndex = "xPassiveIdleTaskIndex";
static const char* CMockString_xTask = "xTask";
static const char* CMockString_xTaskAbortDelay = "xTaskAbortDelay";
static const char* CMockString_xTaskCallApplicationTaskHook = "xTaskCallApplicationTaskHook";
static const char* CMockString_xTaskCatchUpTicks = "xTaskCatchUpTicks";
static const char* CMockString_xTaskCheckForTimeOut = "xTaskCheckForTimeOut";
static const char* CMockString_xTaskCreate = "xTaskCreate";
static const char* CMockString_xTaskCreateAffinitySet = "xTaskCreateAffinitySet";
static const char* CMockString_xTaskCreateRestricted = "xTaskCreateRestricted";
static const char* CMockString_xTaskCreateRestrictedAffinitySet = "xTaskCreateRestrictedAffinitySet";
static const char* CMockString_xTaskCreateRestrictedStatic = "xTaskCreateRestrictedStatic";
static const char* CMockString_xTaskCreateRestrictedStaticAffinitySet = "xTaskCreateRestrictedStaticAffinitySet";
static const char* CMockString_xTaskCreateStatic = "xTaskCreateStatic";
static const char* CMockString_xTaskCreateStaticAffinitySet = "xTaskCreateStaticAffinitySet";
static const char* CMockString_xTaskDelayUntil = "xTaskDelayUntil";
static const char* CMockString_xTaskGenericNotify = "xTaskGenericNotify";
static const char* CMockString_xTaskGenericNotifyFromISR = "xTaskGenericNotifyFromISR";
static const char* CMockString_xTaskGenericNotifyStateClear = "xTaskGenericNotifyStateClear";
static const char* CMockString_xTaskGenericNotifyWait = "xTaskGenericNotifyWait";
static const char* CMockString_xTaskGetApplicationTaskTag = "xTaskGetApplicationTaskTag";
static const char* CMockString_xTaskGetApplicationTaskTagFromISR = "xTaskGetApplicationTaskTagFromISR";
static const char* CMockString_xTaskGetCurrentTaskHandle = "xTaskGetCurrentTaskHandle";
static const char* CMockString_xTaskGetCurrentTaskHandleForCore = "xTaskGetCurrentTaskHandleForCore";
static const char* CMockString_xTaskGetHandle = "xTaskGetHandle";
static const char* CMockString_xTaskGetIdleTaskHandle = "xTaskGetIdleTaskHandle";
static const char* CMockString_xTaskGetIdleTaskHandleForCore = "xTaskGetIdleTaskHandleForCore";
static const char* CMockString_xTaskGetMPUSettings = "xTaskGetMPUSettings";
static const char* CMockString_xTaskGetSchedulerState = "xTaskGetSchedulerState";
static const char* CMockString_xTaskGetStaticBuffers = "xTaskGetStaticBuffers";
static const char* CMockString_xTaskGetTickCount = "xTaskGetTickCount";
static const char* CMockString_xTaskGetTickCountFromISR = "xTaskGetTickCountFromISR";
static const char* CMockString_xTaskIncrementTick = "xTaskIncrementTick";
static const char* CMockString_xTaskPriorityDisinherit = "xTaskPriorityDisinherit";
static const char* CMockString_xTaskPriorityInherit = "xTaskPriorityInherit";
static const char* CMockString_xTaskRemoveFromEventList = "xTaskRemoveFromEventList";
static const char* CMockString_xTaskResumeAll = "xTaskResumeAll";
static const char* CMockString_xTaskResumeFromISR = "xTaskResumeFromISR";
static const char* CMockString_xTaskToDelete = "xTaskToDelete";
static const char* CMockString_xTaskToModify = "xTaskToModify";
static const char* CMockString_xTaskToNotify = "xTaskToNotify";
static const char* CMockString_xTaskToQuery = "xTaskToQuery";
static const char* CMockString_xTaskToResume = "xTaskToResume";
static const char* CMockString_xTaskToSet = "xTaskToSet";
static const char* CMockString_xTaskToSuspend = "xTaskToSuspend";
static const char* CMockString_xTicksToCatchUp = "xTicksToCatchUp";
static const char* CMockString_xTicksToDelay = "xTicksToDelay";
static const char* CMockString_xTicksToJump = "xTicksToJump";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xTimeIncrement = "xTimeIncrement";
static const char* CMockString_xWaitIndefinitely = "xWaitIndefinitely";

typedef struct _CMOCK_xTaskCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskFunction_t Expected_pxTaskCode;
  const char* Expected_pcName;
  configSTACK_DEPTH_TYPE Expected_uxStackDepth;
  void* Expected_pvParameters;
  UBaseType_t Expected_uxPriority;
  TaskHandle_t* Expected_pxCreatedTask;
  char ReturnThruPtr_pvParameters_Used;
  void const* ReturnThruPtr_pvParameters_Val;
  size_t ReturnThruPtr_pvParameters_Size;
  char ReturnThruPtr_pxCreatedTask_Used;
  TaskHandle_t const* ReturnThruPtr_pxCreatedTask_Val;
  size_t ReturnThruPtr_pxCreatedTask_Size;
  char IgnoreArg_pxTaskCode;
  char IgnoreArg_pcName;
  char IgnoreArg_uxStackDepth;
  char IgnoreArg_pvParameters;
  char IgnoreArg_uxPriority;
  char IgnoreArg_pxCreatedTask;

} CMOCK_xTaskCreate_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskFunction_t Expected_pxTaskCode;
  const char* Expected_pcName;
  configSTACK_DEPTH_TYPE Expected_uxStackDepth;
  void* Expected_pvParameters;
  UBaseType_t Expected_uxPriority;
  UBaseType_t Expected_uxCoreAffinityMask;
  TaskHandle_t* Expected_pxCreatedTask;
  char ReturnThruPtr_pvParameters_Used;
  void const* ReturnThruPtr_pvParameters_Val;
  size_t ReturnThruPtr_pvParameters_Size;
  char ReturnThruPtr_pxCreatedTask_Used;
  TaskHandle_t const* ReturnThruPtr_pxCreatedTask_Val;
  size_t ReturnThruPtr_pxCreatedTask_Size;
  char IgnoreArg_pxTaskCode;
  char IgnoreArg_pcName;
  char IgnoreArg_uxStackDepth;
  char IgnoreArg_pvParameters;
  char IgnoreArg_uxPriority;
  char IgnoreArg_uxCoreAffinityMask;
  char IgnoreArg_pxCreatedTask;

} CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;
  TaskFunction_t Expected_pxTaskCode;
  const char* Expected_pcName;
  configSTACK_DEPTH_TYPE Expected_uxStackDepth;
  void* Expected_pvParameters;
  UBaseType_t Expected_uxPriority;
  StackType_t* Expected_puxStackBuffer;
  StaticTask_t* Expected_pxTaskBuffer;
  char ReturnThruPtr_pvParameters_Used;
  void const* ReturnThruPtr_pvParameters_Val;
  size_t ReturnThruPtr_pvParameters_Size;
  char ReturnThruPtr_puxStackBuffer_Used;
  StackType_t const* ReturnThruPtr_puxStackBuffer_Val;
  size_t ReturnThruPtr_puxStackBuffer_Size;
  char ReturnThruPtr_pxTaskBuffer_Used;
  StaticTask_t const* ReturnThruPtr_pxTaskBuffer_Val;
  size_t ReturnThruPtr_pxTaskBuffer_Size;
  char IgnoreArg_pxTaskCode;
  char IgnoreArg_pcName;
  char IgnoreArg_uxStackDepth;
  char IgnoreArg_pvParameters;
  char IgnoreArg_uxPriority;
  char IgnoreArg_puxStackBuffer;
  char IgnoreArg_pxTaskBuffer;

} CMOCK_xTaskCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;
  TaskFunction_t Expected_pxTaskCode;
  const char* Expected_pcName;
  configSTACK_DEPTH_TYPE Expected_uxStackDepth;
  void* Expected_pvParameters;
  UBaseType_t Expected_uxPriority;
  StackType_t* Expected_puxStackBuffer;
  StaticTask_t* Expected_pxTaskBuffer;
  UBaseType_t Expected_uxCoreAffinityMask;
  char ReturnThruPtr_pvParameters_Used;
  void const* ReturnThruPtr_pvParameters_Val;
  size_t ReturnThruPtr_pvParameters_Size;
  char ReturnThruPtr_puxStackBuffer_Used;
  StackType_t const* ReturnThruPtr_puxStackBuffer_Val;
  size_t ReturnThruPtr_puxStackBuffer_Size;
  char ReturnThruPtr_pxTaskBuffer_Used;
  StaticTask_t const* ReturnThruPtr_pxTaskBuffer_Val;
  size_t ReturnThruPtr_pxTaskBuffer_Size;
  char IgnoreArg_pxTaskCode;
  char IgnoreArg_pcName;
  char IgnoreArg_uxStackDepth;
  char IgnoreArg_pvParameters;
  char IgnoreArg_uxPriority;
  char IgnoreArg_puxStackBuffer;
  char IgnoreArg_pxTaskBuffer;
  char IgnoreArg_uxCoreAffinityMask;

} CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateRestricted_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  const TaskParameters_t* Expected_pxTaskDefinition;
  TaskHandle_t* Expected_pxCreatedTask;
  char ReturnThruPtr_pxCreatedTask_Used;
  TaskHandle_t const* ReturnThruPtr_pxCreatedTask_Val;
  size_t ReturnThruPtr_pxCreatedTask_Size;
  char IgnoreArg_pxTaskDefinition;
  char IgnoreArg_pxCreatedTask;

} CMOCK_xTaskCreateRestricted_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  const TaskParameters_t* Expected_pxTaskDefinition;
  UBaseType_t Expected_uxCoreAffinityMask;
  TaskHandle_t* Expected_pxCreatedTask;
  char ReturnThruPtr_pxCreatedTask_Used;
  TaskHandle_t const* ReturnThruPtr_pxCreatedTask_Val;
  size_t ReturnThruPtr_pxCreatedTask_Size;
  char IgnoreArg_pxTaskDefinition;
  char IgnoreArg_uxCoreAffinityMask;
  char IgnoreArg_pxCreatedTask;

} CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  const TaskParameters_t* Expected_pxTaskDefinition;
  TaskHandle_t* Expected_pxCreatedTask;
  char ReturnThruPtr_pxCreatedTask_Used;
  TaskHandle_t const* ReturnThruPtr_pxCreatedTask_Val;
  size_t ReturnThruPtr_pxCreatedTask_Size;
  char IgnoreArg_pxTaskDefinition;
  char IgnoreArg_pxCreatedTask;

} CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  const TaskParameters_t* Expected_pxTaskDefinition;
  UBaseType_t Expected_uxCoreAffinityMask;
  TaskHandle_t* Expected_pxCreatedTask;
  char ReturnThruPtr_pxCreatedTask_Used;
  TaskHandle_t const* ReturnThruPtr_pxCreatedTask_Val;
  size_t ReturnThruPtr_pxCreatedTask_Size;
  char IgnoreArg_pxTaskDefinition;
  char IgnoreArg_uxCoreAffinityMask;
  char IgnoreArg_pxCreatedTask;

} CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE;

typedef struct _CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTaskToModify;
  const MemoryRegion_t* Expected_pxRegions;
  char IgnoreArg_xTaskToModify;
  char IgnoreArg_pxRegions;

} CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE;

typedef struct _CMOCK_vTaskDelete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTaskToDelete;
  char IgnoreArg_xTaskToDelete;

} CMOCK_vTaskDelete_CALL_INSTANCE;

typedef struct _CMOCK_vTaskDelay_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TickType_t Expected_xTicksToDelay;
  char IgnoreArg_xTicksToDelay;

} CMOCK_vTaskDelay_CALL_INSTANCE;

typedef struct _CMOCK_xTaskDelayUntil_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TickType_t* Expected_pxPreviousWakeTime;
  TickType_t Expected_xTimeIncrement;
  char ReturnThruPtr_pxPreviousWakeTime_Used;
  TickType_t const* ReturnThruPtr_pxPreviousWakeTime_Val;
  size_t ReturnThruPtr_pxPreviousWakeTime_Size;
  char IgnoreArg_pxPreviousWakeTime;
  char IgnoreArg_xTimeIncrement;

} CMOCK_xTaskDelayUntil_CALL_INSTANCE;

typedef struct _CMOCK_xTaskAbortDelay_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_xTaskAbortDelay_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskPriorityGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_uxTaskPriorityGet_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE;

typedef struct _CMOCK_eTaskGetState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eTaskState ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_eTaskGetState_CALL_INSTANCE;

typedef struct _CMOCK_vTaskGetInfo_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTask;
  TaskStatus_t* Expected_pxTaskStatus;
  BaseType_t Expected_xGetFreeStackSpace;
  eTaskState Expected_eState;
  char ReturnThruPtr_pxTaskStatus_Used;
  TaskStatus_t const* ReturnThruPtr_pxTaskStatus_Val;
  size_t ReturnThruPtr_pxTaskStatus_Size;
  char IgnoreArg_xTask;
  char IgnoreArg_pxTaskStatus;
  char IgnoreArg_xGetFreeStackSpace;
  char IgnoreArg_eState;

} CMOCK_vTaskGetInfo_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPrioritySet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTask;
  UBaseType_t Expected_uxNewPriority;
  char IgnoreArg_xTask;
  char IgnoreArg_uxNewPriority;

} CMOCK_vTaskPrioritySet_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSuspend_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTaskToSuspend;
  char IgnoreArg_xTaskToSuspend;

} CMOCK_vTaskSuspend_CALL_INSTANCE;

typedef struct _CMOCK_vTaskResume_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTaskToResume;
  char IgnoreArg_xTaskToResume;

} CMOCK_vTaskResume_CALL_INSTANCE;

typedef struct _CMOCK_xTaskResumeFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTaskToResume;
  char IgnoreArg_xTaskToResume;

} CMOCK_xTaskResumeFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTask;
  UBaseType_t Expected_uxCoreAffinityMask;
  char IgnoreArg_xTask;
  char IgnoreArg_uxCoreAffinityMask;

} CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE;

typedef struct _CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  ConstTaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPreemptionDisable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_vTaskPreemptionDisable_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPreemptionEnable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_vTaskPreemptionEnable_CALL_INSTANCE;

typedef struct _CMOCK_vTaskStartScheduler_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskStartScheduler_CALL_INSTANCE;

typedef struct _CMOCK_vTaskEndScheduler_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskEndScheduler_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSuspendAll_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskSuspendAll_CALL_INSTANCE;

typedef struct _CMOCK_xTaskResumeAll_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;

} CMOCK_xTaskResumeAll_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetTickCount_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TickType_t ReturnVal;

} CMOCK_xTaskGetTickCount_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TickType_t ReturnVal;

} CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;

} CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE;

typedef struct _CMOCK_pcTaskGetName_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  char* ReturnVal;
  TaskHandle_t Expected_xTaskToQuery;
  char IgnoreArg_xTaskToQuery;

} CMOCK_pcTaskGetName_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;
  const char* Expected_pcNameToQuery;
  char IgnoreArg_pcNameToQuery;

} CMOCK_xTaskGetHandle_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  StackType_t** Expected_ppuxStackBuffer;
  StaticTask_t** Expected_ppxTaskBuffer;
  char ReturnThruPtr_ppuxStackBuffer_Used;
  StackType_t* const* ReturnThruPtr_ppuxStackBuffer_Val;
  size_t ReturnThruPtr_ppuxStackBuffer_Size;
  char ReturnThruPtr_ppxTaskBuffer_Used;
  StaticTask_t* const* ReturnThruPtr_ppxTaskBuffer_Val;
  size_t ReturnThruPtr_ppxTaskBuffer_Size;
  char IgnoreArg_xTask;
  char IgnoreArg_ppuxStackBuffer;
  char IgnoreArg_ppxTaskBuffer;

} CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  configSTACK_DEPTH_TYPE ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTask;
  TaskHookFunction_t Expected_pxHookFunction;
  char IgnoreArg_xTask;
  char IgnoreArg_pxHookFunction;

} CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHookFunction_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHookFunction_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTaskToSet;
  BaseType_t Expected_xIndex;
  void* Expected_pvValue;
  char ReturnThruPtr_pvValue_Used;
  void const* ReturnThruPtr_pvValue_Val;
  size_t ReturnThruPtr_pvValue_Size;
  char IgnoreArg_xTaskToSet;
  char IgnoreArg_xIndex;
  char IgnoreArg_pvValue;

} CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE;

typedef struct _CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  void* ReturnVal;
  TaskHandle_t Expected_xTaskToQuery;
  BaseType_t Expected_xIndex;
  char IgnoreArg_xTaskToQuery;
  char IgnoreArg_xIndex;

} CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE;

typedef struct _CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTask;
  char* Expected_pcTaskName;
  char ReturnThruPtr_pcTaskName_Used;
  char const* ReturnThruPtr_pcTaskName_Val;
  size_t ReturnThruPtr_pcTaskName_Size;
  char IgnoreArg_xTask;
  char IgnoreArg_pcTaskName;

} CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE;

typedef struct _CMOCK_vApplicationIdleHook_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vApplicationIdleHook_CALL_INSTANCE;

typedef struct _CMOCK_vApplicationTickHook_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vApplicationTickHook_CALL_INSTANCE;

typedef struct _CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  StaticTask_t** Expected_ppxIdleTaskTCBBuffer;
  StackType_t** Expected_ppxIdleTaskStackBuffer;
  configSTACK_DEPTH_TYPE* Expected_puxIdleTaskStackSize;
  char ReturnThruPtr_ppxIdleTaskTCBBuffer_Used;
  StaticTask_t* const* ReturnThruPtr_ppxIdleTaskTCBBuffer_Val;
  size_t ReturnThruPtr_ppxIdleTaskTCBBuffer_Size;
  char ReturnThruPtr_ppxIdleTaskStackBuffer_Used;
  StackType_t* const* ReturnThruPtr_ppxIdleTaskStackBuffer_Val;
  size_t ReturnThruPtr_ppxIdleTaskStackBuffer_Size;
  char ReturnThruPtr_puxIdleTaskStackSize_Used;
  configSTACK_DEPTH_TYPE const* ReturnThruPtr_puxIdleTaskStackSize_Val;
  size_t ReturnThruPtr_puxIdleTaskStackSize_Size;
  char IgnoreArg_ppxIdleTaskTCBBuffer;
  char IgnoreArg_ppxIdleTaskStackBuffer;
  char IgnoreArg_puxIdleTaskStackSize;

} CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE;

typedef struct _CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  StaticTask_t** Expected_ppxIdleTaskTCBBuffer;
  StackType_t** Expected_ppxIdleTaskStackBuffer;
  configSTACK_DEPTH_TYPE* Expected_puxIdleTaskStackSize;
  BaseType_t Expected_xPassiveIdleTaskIndex;
  char ReturnThruPtr_ppxIdleTaskTCBBuffer_Used;
  StaticTask_t* const* ReturnThruPtr_ppxIdleTaskTCBBuffer_Val;
  size_t ReturnThruPtr_ppxIdleTaskTCBBuffer_Size;
  char ReturnThruPtr_ppxIdleTaskStackBuffer_Used;
  StackType_t* const* ReturnThruPtr_ppxIdleTaskStackBuffer_Val;
  size_t ReturnThruPtr_ppxIdleTaskStackBuffer_Size;
  char ReturnThruPtr_puxIdleTaskStackSize_Used;
  configSTACK_DEPTH_TYPE const* ReturnThruPtr_puxIdleTaskStackSize_Val;
  size_t ReturnThruPtr_puxIdleTaskStackSize_Size;
  char IgnoreArg_ppxIdleTaskTCBBuffer;
  char IgnoreArg_ppxIdleTaskStackBuffer;
  char IgnoreArg_puxIdleTaskStackSize;
  char IgnoreArg_xPassiveIdleTaskIndex;

} CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  void* Expected_pvParameter;
  char ReturnThruPtr_pvParameter_Used;
  void const* ReturnThruPtr_pvParameter_Val;
  size_t ReturnThruPtr_pvParameter_Size;
  char IgnoreArg_xTask;
  char IgnoreArg_pvParameter;

} CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;

} CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;
  BaseType_t Expected_xCoreID;
  char IgnoreArg_xCoreID;

} CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetSystemState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  TaskStatus_t* Expected_pxTaskStatusArray;
  UBaseType_t Expected_uxArraySize;
  configRUN_TIME_COUNTER_TYPE* Expected_pulTotalRunTime;
  char ReturnThruPtr_pxTaskStatusArray_Used;
  TaskStatus_t const* ReturnThruPtr_pxTaskStatusArray_Val;
  size_t ReturnThruPtr_pxTaskStatusArray_Size;
  char ReturnThruPtr_pulTotalRunTime_Used;
  configRUN_TIME_COUNTER_TYPE const* ReturnThruPtr_pulTotalRunTime_Val;
  size_t ReturnThruPtr_pulTotalRunTime_Size;
  char IgnoreArg_pxTaskStatusArray;
  char IgnoreArg_uxArraySize;
  char IgnoreArg_pulTotalRunTime;

} CMOCK_uxTaskGetSystemState_CALL_INSTANCE;

typedef struct _CMOCK_vTaskListTasks_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  char* Expected_pcWriteBuffer;
  size_t Expected_uxBufferLength;
  char ReturnThruPtr_pcWriteBuffer_Used;
  char const* ReturnThruPtr_pcWriteBuffer_Val;
  size_t ReturnThruPtr_pcWriteBuffer_Size;
  char IgnoreArg_pcWriteBuffer;
  char IgnoreArg_uxBufferLength;

} CMOCK_vTaskListTasks_CALL_INSTANCE;

typedef struct _CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  char* Expected_pcWriteBuffer;
  size_t Expected_uxBufferLength;
  char ReturnThruPtr_pcWriteBuffer_Used;
  char const* ReturnThruPtr_pcWriteBuffer_Val;
  size_t ReturnThruPtr_pcWriteBuffer_Size;
  char IgnoreArg_pcWriteBuffer;
  char IgnoreArg_uxBufferLength;

} CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE;

typedef struct _CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  configRUN_TIME_COUNTER_TYPE ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE;

typedef struct _CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  configRUN_TIME_COUNTER_TYPE ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE;

typedef struct _CMOCK_ulTaskGetIdleRunTimeCounter_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  configRUN_TIME_COUNTER_TYPE ReturnVal;

} CMOCK_ulTaskGetIdleRunTimeCounter_CALL_INSTANCE;

typedef struct _CMOCK_ulTaskGetIdleRunTimePercent_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  configRUN_TIME_COUNTER_TYPE ReturnVal;

} CMOCK_ulTaskGetIdleRunTimePercent_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGenericNotify_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTaskToNotify;
  UBaseType_t Expected_uxIndexToNotify;
  uint32_t Expected_ulValue;
  eNotifyAction Expected_eAction;
  uint32_t* Expected_pulPreviousNotificationValue;
  char ReturnThruPtr_pulPreviousNotificationValue_Used;
  uint32_t const* ReturnThruPtr_pulPreviousNotificationValue_Val;
  size_t ReturnThruPtr_pulPreviousNotificationValue_Size;
  char IgnoreArg_xTaskToNotify;
  char IgnoreArg_uxIndexToNotify;
  char IgnoreArg_ulValue;
  char IgnoreArg_eAction;
  char IgnoreArg_pulPreviousNotificationValue;

} CMOCK_xTaskGenericNotify_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTaskToNotify;
  UBaseType_t Expected_uxIndexToNotify;
  uint32_t Expected_ulValue;
  eNotifyAction Expected_eAction;
  uint32_t* Expected_pulPreviousNotificationValue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  char ReturnThruPtr_pulPreviousNotificationValue_Used;
  uint32_t const* ReturnThruPtr_pulPreviousNotificationValue_Val;
  size_t ReturnThruPtr_pulPreviousNotificationValue_Size;
  char ReturnThruPtr_pxHigherPriorityTaskWoken_Used;
  BaseType_t const* ReturnThruPtr_pxHigherPriorityTaskWoken_Val;
  size_t ReturnThruPtr_pxHigherPriorityTaskWoken_Size;
  char IgnoreArg_xTaskToNotify;
  char IgnoreArg_uxIndexToNotify;
  char IgnoreArg_ulValue;
  char IgnoreArg_eAction;
  char IgnoreArg_pulPreviousNotificationValue;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  UBaseType_t Expected_uxIndexToWaitOn;
  uint32_t Expected_ulBitsToClearOnEntry;
  uint32_t Expected_ulBitsToClearOnExit;
  uint32_t* Expected_pulNotificationValue;
  TickType_t Expected_xTicksToWait;
  char ReturnThruPtr_pulNotificationValue_Used;
  uint32_t const* ReturnThruPtr_pulNotificationValue_Val;
  size_t ReturnThruPtr_pulNotificationValue_Size;
  char IgnoreArg_uxIndexToWaitOn;
  char IgnoreArg_ulBitsToClearOnEntry;
  char IgnoreArg_ulBitsToClearOnExit;
  char IgnoreArg_pulNotificationValue;
  char IgnoreArg_xTicksToWait;

} CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE;

typedef struct _CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTaskToNotify;
  UBaseType_t Expected_uxIndexToNotify;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  char ReturnThruPtr_pxHigherPriorityTaskWoken_Used;
  BaseType_t const* ReturnThruPtr_pxHigherPriorityTaskWoken_Val;
  size_t ReturnThruPtr_pxHigherPriorityTaskWoken_Size;
  char IgnoreArg_xTaskToNotify;
  char IgnoreArg_uxIndexToNotify;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32_t ReturnVal;
  UBaseType_t Expected_uxIndexToWaitOn;
  BaseType_t Expected_xClearCountOnExit;
  TickType_t Expected_xTicksToWait;
  char IgnoreArg_uxIndexToWaitOn;
  char IgnoreArg_xClearCountOnExit;
  char IgnoreArg_xTicksToWait;

} CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  UBaseType_t Expected_uxIndexToClear;
  char IgnoreArg_xTask;
  char IgnoreArg_uxIndexToClear;

} CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE;

typedef struct _CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32_t ReturnVal;
  TaskHandle_t Expected_xTask;
  UBaseType_t Expected_uxIndexToClear;
  uint32_t Expected_ulBitsToClear;
  char IgnoreArg_xTask;
  char IgnoreArg_uxIndexToClear;
  char IgnoreArg_ulBitsToClear;

} CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSetTimeOutState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TimeOut_t* Expected_pxTimeOut;
  char ReturnThruPtr_pxTimeOut_Used;
  TimeOut_t const* ReturnThruPtr_pxTimeOut_Val;
  size_t ReturnThruPtr_pxTimeOut_Size;
  char IgnoreArg_pxTimeOut;

} CMOCK_vTaskSetTimeOutState_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TimeOut_t* Expected_pxTimeOut;
  TickType_t* Expected_pxTicksToWait;
  char ReturnThruPtr_pxTimeOut_Used;
  TimeOut_t const* ReturnThruPtr_pxTimeOut_Val;
  size_t ReturnThruPtr_pxTimeOut_Size;
  char ReturnThruPtr_pxTicksToWait_Used;
  TickType_t const* ReturnThruPtr_pxTicksToWait_Val;
  size_t ReturnThruPtr_pxTicksToWait_Size;
  char IgnoreArg_pxTimeOut;
  char IgnoreArg_pxTicksToWait;

} CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCatchUpTicks_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TickType_t Expected_xTicksToCatchUp;
  char IgnoreArg_xTicksToCatchUp;

} CMOCK_xTaskCatchUpTicks_CALL_INSTANCE;

typedef struct _CMOCK_vTaskResetState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskResetState_CALL_INSTANCE;

typedef struct _CMOCK_xTaskIncrementTick_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;

} CMOCK_xTaskIncrementTick_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  List_t* Expected_pxEventList;
  TickType_t Expected_xTicksToWait;
  char ReturnThruPtr_pxEventList_Used;
  List_t const* ReturnThruPtr_pxEventList_Val;
  size_t ReturnThruPtr_pxEventList_Size;
  char IgnoreArg_pxEventList;
  char IgnoreArg_xTicksToWait;

} CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  List_t* Expected_pxEventList;
  TickType_t Expected_xItemValue;
  TickType_t Expected_xTicksToWait;
  char ReturnThruPtr_pxEventList_Used;
  List_t const* ReturnThruPtr_pxEventList_Val;
  size_t ReturnThruPtr_pxEventList_Size;
  char IgnoreArg_pxEventList;
  char IgnoreArg_xItemValue;
  char IgnoreArg_xTicksToWait;

} CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  List_t* Expected_pxEventList;
  TickType_t Expected_xTicksToWait;
  BaseType_t Expected_xWaitIndefinitely;
  char ReturnThruPtr_pxEventList_Used;
  List_t const* ReturnThruPtr_pxEventList_Val;
  size_t ReturnThruPtr_pxEventList_Size;
  char IgnoreArg_pxEventList;
  char IgnoreArg_xTicksToWait;
  char IgnoreArg_xWaitIndefinitely;

} CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE;

typedef struct _CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  const List_t* Expected_pxEventList;
  char IgnoreArg_pxEventList;

} CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  ListItem_t* Expected_pxEventListItem;
  TickType_t Expected_xItemValue;
  char ReturnThruPtr_pxEventListItem_Used;
  ListItem_t const* ReturnThruPtr_pxEventListItem_Val;
  size_t ReturnThruPtr_pxEventListItem_Size;
  char IgnoreArg_pxEventListItem;
  char IgnoreArg_xItemValue;

} CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSwitchContext_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskSwitchContext_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TickType_t ReturnVal;

} CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;

} CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;
  BaseType_t Expected_xCoreID;
  char IgnoreArg_xCoreID;

} CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE;

typedef struct _CMOCK_vTaskMissedYield_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskMissedYield_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetSchedulerState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;

} CMOCK_xTaskGetSchedulerState_CALL_INSTANCE;

typedef struct _CMOCK_xTaskPriorityInherit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_pxMutexHolder;
  char IgnoreArg_pxMutexHolder;

} CMOCK_xTaskPriorityInherit_CALL_INSTANCE;

typedef struct _CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_pxMutexHolder;
  char IgnoreArg_pxMutexHolder;

} CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_pxMutexHolder;
  UBaseType_t Expected_uxHighestPriorityWaitingTask;
  char IgnoreArg_pxMutexHolder;
  char IgnoreArg_uxHighestPriorityWaitingTask;

} CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSetTaskNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xTask;
  UBaseType_t Expected_uxHandle;
  char IgnoreArg_xTask;
  char IgnoreArg_uxHandle;

} CMOCK_vTaskSetTaskNumber_CALL_INSTANCE;

typedef struct _CMOCK_vTaskStepTick_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TickType_t Expected_xTicksToJump;
  char IgnoreArg_xTicksToJump;

} CMOCK_vTaskStepTick_CALL_INSTANCE;

typedef struct _CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eSleepModeStatus ReturnVal;

} CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE;

typedef struct _CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;

} CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE;

typedef struct _CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TimeOut_t* Expected_pxTimeOut;
  char ReturnThruPtr_pxTimeOut_Used;
  TimeOut_t const* ReturnThruPtr_pxTimeOut_Val;
  size_t ReturnThruPtr_pxTimeOut_Size;
  char IgnoreArg_pxTimeOut;

} CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE;

typedef struct _CMOCK_vTaskYieldWithinAPI_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskYieldWithinAPI_CALL_INSTANCE;

typedef struct _CMOCK_vTaskEnterCritical_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskEnterCritical_CALL_INSTANCE;

typedef struct _CMOCK_vTaskExitCritical_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;

} CMOCK_vTaskExitCritical_CALL_INSTANCE;

typedef struct _CMOCK_vTaskEnterCriticalFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;

} CMOCK_vTaskEnterCriticalFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t Expected_uxSavedInterruptStatus;
  char IgnoreArg_uxSavedInterruptStatus;

} CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetMPUSettings_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  xMPU_SETTINGS* ReturnVal;
  TaskHandle_t Expected_xTask;
  char IgnoreArg_xTask;

} CMOCK_xTaskGetMPUSettings_CALL_INSTANCE;

typedef struct _CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xExternalTaskHandle;
  int32_t Expected_lExternalKernelObjectHandle;
  char IgnoreArg_xExternalTaskHandle;
  char IgnoreArg_lExternalKernelObjectHandle;

} CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE;

typedef struct _CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xExternalTaskHandle;
  int32_t Expected_lExternalKernelObjectHandle;
  char IgnoreArg_xExternalTaskHandle;
  char IgnoreArg_lExternalKernelObjectHandle;

} CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE;

typedef struct _CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xInternalTaskHandle;
  int32_t Expected_lInternalIndexOfKernelObject;
  char IgnoreArg_xInternalTaskHandle;
  char IgnoreArg_lInternalIndexOfKernelObject;

} CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE;

typedef struct _CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t Expected_xInternalTaskHandle;
  int32_t Expected_lInternalIndexOfKernelObject;
  char IgnoreArg_xInternalTaskHandle;
  char IgnoreArg_lInternalIndexOfKernelObject;

} CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE;

static struct taskInstance
{
  CMOCK_MEM_INDEX_TYPE xTaskCreate_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateAffinitySet_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateStaticAffinitySet_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateRestricted_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateRestrictedAffinitySet_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateRestrictedStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateRestrictedStaticAffinitySet_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskAllocateMPURegions_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskDelete_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskDelay_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskDelayUntil_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskAbortDelay_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskPriorityGet_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskPriorityGetFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskBasePriorityGet_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskBasePriorityGetFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE eTaskGetState_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskGetInfo_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPrioritySet_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSuspend_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskResume_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskResumeFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskCoreAffinitySet_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskCoreAffinityGet_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPreemptionDisable_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPreemptionEnable_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskStartScheduler_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskEndScheduler_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSuspendAll_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskResumeAll_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetTickCount_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetTickCountFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetNumberOfTasks_CallInstance;
  CMOCK_MEM_INDEX_TYPE pcTaskGetName_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetHandle_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetStaticBuffers_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetStackHighWaterMark_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetStackHighWaterMark2_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSetApplicationTaskTag_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetApplicationTaskTag_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetApplicationTaskTagFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSetThreadLocalStoragePointer_CallInstance;
  CMOCK_MEM_INDEX_TYPE pvTaskGetThreadLocalStoragePointer_CallInstance;
  CMOCK_MEM_INDEX_TYPE vApplicationStackOverflowHook_CallInstance;
  CMOCK_MEM_INDEX_TYPE vApplicationIdleHook_CallInstance;
  CMOCK_MEM_INDEX_TYPE vApplicationTickHook_CallInstance;
  CMOCK_MEM_INDEX_TYPE vApplicationGetIdleTaskMemory_CallInstance;
  CMOCK_MEM_INDEX_TYPE vApplicationGetPassiveIdleTaskMemory_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCallApplicationTaskHook_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetIdleTaskHandle_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetIdleTaskHandleForCore_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetSystemState_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskListTasks_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskGetRunTimeStatistics_CallInstance;
  CMOCK_MEM_INDEX_TYPE ulTaskGetRunTimeCounter_CallInstance;
  CMOCK_MEM_INDEX_TYPE ulTaskGetRunTimePercent_CallInstance;
  CMOCK_MEM_INDEX_TYPE ulTaskGetIdleRunTimeCounter_CallInstance;
  CMOCK_MEM_INDEX_TYPE ulTaskGetIdleRunTimePercent_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGenericNotify_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGenericNotifyFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGenericNotifyWait_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskGenericNotifyGiveFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE ulTaskGenericNotifyTake_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGenericNotifyStateClear_CallInstance;
  CMOCK_MEM_INDEX_TYPE ulTaskGenericNotifyValueClear_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSetTimeOutState_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCheckForTimeOut_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCatchUpTicks_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskResetState_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskIncrementTick_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPlaceOnEventList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPlaceOnUnorderedEventList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPlaceOnEventListRestricted_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskRemoveFromEventList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskRemoveFromUnorderedEventList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSwitchContext_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskResetEventItemValue_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetCurrentTaskHandle_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetCurrentTaskHandleForCore_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskMissedYield_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetSchedulerState_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskPriorityInherit_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskPriorityDisinherit_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPriorityDisinheritAfterTimeout_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetTaskNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSetTaskNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskStepTick_CallInstance;
  CMOCK_MEM_INDEX_TYPE eTaskConfirmSleepModeStatus_CallInstance;
  CMOCK_MEM_INDEX_TYPE pvTaskIncrementMutexHeldCount_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskInternalSetTimeOutState_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskYieldWithinAPI_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskEnterCritical_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskExitCritical_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskEnterCriticalFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskExitCriticalFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetMPUSettings_CallInstance;
  CMOCK_MEM_INDEX_TYPE vGrantAccessToKernelObject_CallInstance;
  CMOCK_MEM_INDEX_TYPE vRevokeAccessToKernelObject_CallInstance;
  CMOCK_MEM_INDEX_TYPE vPortGrantAccessToKernelObject_CallInstance;
  CMOCK_MEM_INDEX_TYPE vPortRevokeAccessToKernelObject_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void task_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xTaskCreate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateAffinitySet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateAffinitySet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateStaticAffinitySet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateStaticAffinitySet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateRestricted_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateRestricted);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateRestrictedAffinitySet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateRestrictedAffinitySet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateRestrictedStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateRestrictedStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateRestrictedStaticAffinitySet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskAllocateMPURegions_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskAllocateMPURegions);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskDelete_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskDelete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskDelay_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskDelay);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskDelayUntil_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskDelayUntil);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskAbortDelay_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskAbortDelay);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskPriorityGet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskPriorityGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskPriorityGetFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskPriorityGetFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskBasePriorityGet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskBasePriorityGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskBasePriorityGetFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskBasePriorityGetFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.eTaskGetState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_eTaskGetState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskGetInfo_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskGetInfo);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPrioritySet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPrioritySet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSuspend_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSuspend);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskResume_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskResume);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskResumeFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskResumeFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskCoreAffinitySet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskCoreAffinitySet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskCoreAffinityGet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskCoreAffinityGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPreemptionDisable_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPreemptionDisable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPreemptionEnable_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPreemptionEnable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskStartScheduler_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskStartScheduler);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskEndScheduler_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskEndScheduler);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSuspendAll_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSuspendAll);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskResumeAll_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskResumeAll);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetTickCount_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetTickCount);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetTickCountFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetTickCountFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetNumberOfTasks_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetNumberOfTasks);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pcTaskGetName_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pcTaskGetName);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetHandle_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetStaticBuffers_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetStaticBuffers);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetStackHighWaterMark_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetStackHighWaterMark);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetStackHighWaterMark2_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetStackHighWaterMark2);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSetApplicationTaskTag_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSetApplicationTaskTag);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetApplicationTaskTag_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetApplicationTaskTag);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetApplicationTaskTagFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetApplicationTaskTagFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSetThreadLocalStoragePointer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSetThreadLocalStoragePointer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pvTaskGetThreadLocalStoragePointer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pvTaskGetThreadLocalStoragePointer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vApplicationStackOverflowHook_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vApplicationStackOverflowHook);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vApplicationIdleHook_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vApplicationIdleHook);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vApplicationTickHook_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vApplicationTickHook);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vApplicationGetIdleTaskMemory_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vApplicationGetIdleTaskMemory);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vApplicationGetPassiveIdleTaskMemory);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCallApplicationTaskHook_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCallApplicationTaskHook);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetIdleTaskHandle_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetIdleTaskHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetIdleTaskHandleForCore_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetIdleTaskHandleForCore);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetSystemState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetSystemState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskListTasks_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskListTasks);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskGetRunTimeStatistics_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskGetRunTimeStatistics);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ulTaskGetRunTimeCounter_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulTaskGetRunTimeCounter);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ulTaskGetRunTimePercent_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulTaskGetRunTimePercent);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ulTaskGetIdleRunTimeCounter_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulTaskGetIdleRunTimeCounter);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ulTaskGetIdleRunTimePercent_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulTaskGetIdleRunTimePercent);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGenericNotify_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGenericNotify);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGenericNotifyFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGenericNotifyFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGenericNotifyWait_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGenericNotifyWait);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskGenericNotifyGiveFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskGenericNotifyGiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ulTaskGenericNotifyTake_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulTaskGenericNotifyTake);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGenericNotifyStateClear_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGenericNotifyStateClear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ulTaskGenericNotifyValueClear_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulTaskGenericNotifyValueClear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSetTimeOutState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSetTimeOutState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCheckForTimeOut_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCheckForTimeOut);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCatchUpTicks_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCatchUpTicks);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskResetState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskResetState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskIncrementTick_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskIncrementTick);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPlaceOnEventList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPlaceOnEventList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPlaceOnUnorderedEventList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPlaceOnUnorderedEventList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPlaceOnEventListRestricted_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPlaceOnEventListRestricted);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskRemoveFromEventList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskRemoveFromEventList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskRemoveFromUnorderedEventList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskRemoveFromUnorderedEventList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSwitchContext_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSwitchContext);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskResetEventItemValue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskResetEventItemValue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetCurrentTaskHandle_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetCurrentTaskHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetCurrentTaskHandleForCore_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetCurrentTaskHandleForCore);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskMissedYield_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskMissedYield);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetSchedulerState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetSchedulerState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskPriorityInherit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskPriorityInherit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskPriorityDisinherit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskPriorityDisinherit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPriorityDisinheritAfterTimeout);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetTaskNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetTaskNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSetTaskNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSetTaskNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskStepTick_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskStepTick);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.eTaskConfirmSleepModeStatus_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_eTaskConfirmSleepModeStatus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pvTaskIncrementMutexHeldCount_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pvTaskIncrementMutexHeldCount);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskInternalSetTimeOutState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskInternalSetTimeOutState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskYieldWithinAPI_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskYieldWithinAPI);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskEnterCritical_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskEnterCritical);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskExitCritical_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskExitCritical);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskEnterCriticalFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskEnterCriticalFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskExitCriticalFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskExitCriticalFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetMPUSettings_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetMPUSettings);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vGrantAccessToKernelObject_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGrantAccessToKernelObject);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vRevokeAccessToKernelObject_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vRevokeAccessToKernelObject);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vPortGrantAccessToKernelObject_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vPortGrantAccessToKernelObject);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vPortRevokeAccessToKernelObject_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vPortRevokeAccessToKernelObject);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void task_Init(void)
{
  task_Destroy();
}

void task_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

BaseType_t xTaskCreate(TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreate);
  cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreate_CallInstance);
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskCode)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pxTaskCode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode), sizeof(TaskFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pcName)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pcName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcName, pcName, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxStackDepth)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_uxStackDepth);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxStackDepth), (void*)(&uxStackDepth), sizeof(configSTACK_DEPTH_TYPE), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameters)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pvParameters);
    if (cmock_call_instance->Expected_pvParameters == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameters, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameters, pvParameters, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxPriority)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_uxPriority);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxCreatedTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pxCreatedTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pvParameters_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvParameters, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvParameters, (const void*)cmock_call_instance->ReturnThruPtr_pvParameters_Val,
      cmock_call_instance->ReturnThruPtr_pvParameters_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxCreatedTask, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxCreatedTask, (const void*)cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val,
      cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreate(CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask);
void CMockExpectParameters_xTaskCreate(CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode),
         sizeof(TaskFunction_t[sizeof(pxTaskCode) == sizeof(TaskFunction_t) ? 1 : -1])); /* add TaskFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxTaskCode = 0;
  cmock_call_instance->Expected_pcName = pcName;
  cmock_call_instance->IgnoreArg_pcName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxStackDepth), (void*)(&uxStackDepth),
         sizeof(configSTACK_DEPTH_TYPE[sizeof(uxStackDepth) == sizeof(configSTACK_DEPTH_TYPE) ? 1 : -1])); /* add configSTACK_DEPTH_TYPE to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxStackDepth = 0;
  cmock_call_instance->Expected_pvParameters = pvParameters;
  cmock_call_instance->IgnoreArg_pvParameters = 0;
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority),
         sizeof(UBaseType_t[sizeof(uxPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxPriority = 0;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->IgnoreArg_pxCreatedTask = 0;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 0;
}

void xTaskCreate_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCreate(cmock_call_instance, pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreate_CMockReturnMemThruPtr_pvParameters(UNITY_LINE_TYPE cmock_line, void const* pvParameters, size_t cmock_size)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvParameters_Val = pvParameters;
  cmock_call_instance->ReturnThruPtr_pvParameters_Size = cmock_size;
}

void xTaskCreate_CMockReturnMemThruPtr_pxCreatedTask(UNITY_LINE_TYPE cmock_line, TaskHandle_t const* pxCreatedTask, size_t cmock_size)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val = pxCreatedTask;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size = cmock_size;
}

void xTaskCreate_CMockIgnoreArg_pxTaskCode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskCode = 1;
}

void xTaskCreate_CMockIgnoreArg_pcName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcName = 1;
}

void xTaskCreate_CMockIgnoreArg_uxStackDepth(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxStackDepth = 1;
}

void xTaskCreate_CMockIgnoreArg_pvParameters(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameters = 1;
}

void xTaskCreate_CMockIgnoreArg_uxPriority(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxPriority = 1;
}

void xTaskCreate_CMockIgnoreArg_pxCreatedTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCreatedTask = 1;
}

BaseType_t xTaskCreateAffinitySet(TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, UBaseType_t uxCoreAffinityMask, TaskHandle_t* const pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateAffinitySet);
  cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateAffinitySet_CallInstance);
  Mock.xTaskCreateAffinitySet_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateAffinitySet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskCode)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateAffinitySet,CMockString_pxTaskCode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode), sizeof(TaskFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pcName)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateAffinitySet,CMockString_pcName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcName, pcName, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxStackDepth)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateAffinitySet,CMockString_uxStackDepth);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxStackDepth), (void*)(&uxStackDepth), sizeof(configSTACK_DEPTH_TYPE), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameters)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateAffinitySet,CMockString_pvParameters);
    if (cmock_call_instance->Expected_pvParameters == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameters, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameters, pvParameters, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxPriority)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateAffinitySet,CMockString_uxPriority);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxCoreAffinityMask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateAffinitySet,CMockString_uxCoreAffinityMask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxCreatedTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateAffinitySet,CMockString_pxCreatedTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pvParameters_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvParameters, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvParameters, (const void*)cmock_call_instance->ReturnThruPtr_pvParameters_Val,
      cmock_call_instance->ReturnThruPtr_pvParameters_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxCreatedTask, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxCreatedTask, (const void*)cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val,
      cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateAffinitySet(CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, UBaseType_t uxCoreAffinityMask, TaskHandle_t* const pxCreatedTask);
void CMockExpectParameters_xTaskCreateAffinitySet(CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, UBaseType_t uxCoreAffinityMask, TaskHandle_t* const pxCreatedTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode),
         sizeof(TaskFunction_t[sizeof(pxTaskCode) == sizeof(TaskFunction_t) ? 1 : -1])); /* add TaskFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxTaskCode = 0;
  cmock_call_instance->Expected_pcName = pcName;
  cmock_call_instance->IgnoreArg_pcName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxStackDepth), (void*)(&uxStackDepth),
         sizeof(configSTACK_DEPTH_TYPE[sizeof(uxStackDepth) == sizeof(configSTACK_DEPTH_TYPE) ? 1 : -1])); /* add configSTACK_DEPTH_TYPE to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxStackDepth = 0;
  cmock_call_instance->Expected_pvParameters = pvParameters;
  cmock_call_instance->IgnoreArg_pvParameters = 0;
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority),
         sizeof(UBaseType_t[sizeof(uxPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxPriority = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask),
         sizeof(UBaseType_t[sizeof(uxCoreAffinityMask) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 0;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->IgnoreArg_pxCreatedTask = 0;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 0;
}

void xTaskCreateAffinitySet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE));
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCreateAffinitySet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, UBaseType_t uxCoreAffinityMask, TaskHandle_t* const pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE));
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCreateAffinitySet(cmock_call_instance, pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, uxCoreAffinityMask, pxCreatedTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreateAffinitySet_CMockReturnMemThruPtr_pvParameters(UNITY_LINE_TYPE cmock_line, void const* pvParameters, size_t cmock_size)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvParameters_Val = pvParameters;
  cmock_call_instance->ReturnThruPtr_pvParameters_Size = cmock_size;
}

void xTaskCreateAffinitySet_CMockReturnMemThruPtr_pxCreatedTask(UNITY_LINE_TYPE cmock_line, TaskHandle_t const* pxCreatedTask, size_t cmock_size)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val = pxCreatedTask;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size = cmock_size;
}

void xTaskCreateAffinitySet_CMockIgnoreArg_pxTaskCode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskCode = 1;
}

void xTaskCreateAffinitySet_CMockIgnoreArg_pcName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcName = 1;
}

void xTaskCreateAffinitySet_CMockIgnoreArg_uxStackDepth(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxStackDepth = 1;
}

void xTaskCreateAffinitySet_CMockIgnoreArg_pvParameters(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameters = 1;
}

void xTaskCreateAffinitySet_CMockIgnoreArg_uxPriority(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxPriority = 1;
}

void xTaskCreateAffinitySet_CMockIgnoreArg_uxCoreAffinityMask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 1;
}

void xTaskCreateAffinitySet_CMockIgnoreArg_pxCreatedTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCreatedTask = 1;
}

TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateStatic);
  cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateStatic_CallInstance);
  Mock.xTaskCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskCode)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_pxTaskCode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode), sizeof(TaskFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pcName)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_pcName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcName, pcName, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxStackDepth)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_uxStackDepth);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxStackDepth), (void*)(&uxStackDepth), sizeof(configSTACK_DEPTH_TYPE), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameters)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_pvParameters);
    if (cmock_call_instance->Expected_pvParameters == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameters, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameters, pvParameters, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxPriority)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_uxPriority);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_puxStackBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_puxStackBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_puxStackBuffer), (void*)(puxStackBuffer), sizeof(StackType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxTaskBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_pxTaskBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskBuffer), (void*)(pxTaskBuffer), sizeof(StaticTask_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pvParameters_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvParameters, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvParameters, (const void*)cmock_call_instance->ReturnThruPtr_pvParameters_Val,
      cmock_call_instance->ReturnThruPtr_pvParameters_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_puxStackBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(puxStackBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)puxStackBuffer, (const void*)cmock_call_instance->ReturnThruPtr_puxStackBuffer_Val,
      cmock_call_instance->ReturnThruPtr_puxStackBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTaskBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTaskBuffer, (const void*)cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateStatic(CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer);
void CMockExpectParameters_xTaskCreateStatic(CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode),
         sizeof(TaskFunction_t[sizeof(pxTaskCode) == sizeof(TaskFunction_t) ? 1 : -1])); /* add TaskFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxTaskCode = 0;
  cmock_call_instance->Expected_pcName = pcName;
  cmock_call_instance->IgnoreArg_pcName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxStackDepth), (void*)(&uxStackDepth),
         sizeof(configSTACK_DEPTH_TYPE[sizeof(uxStackDepth) == sizeof(configSTACK_DEPTH_TYPE) ? 1 : -1])); /* add configSTACK_DEPTH_TYPE to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxStackDepth = 0;
  cmock_call_instance->Expected_pvParameters = pvParameters;
  cmock_call_instance->IgnoreArg_pvParameters = 0;
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority),
         sizeof(UBaseType_t[sizeof(uxPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxPriority = 0;
  cmock_call_instance->Expected_puxStackBuffer = puxStackBuffer;
  cmock_call_instance->IgnoreArg_puxStackBuffer = 0;
  cmock_call_instance->ReturnThruPtr_puxStackBuffer_Used = 0;
  cmock_call_instance->Expected_pxTaskBuffer = pxTaskBuffer;
  cmock_call_instance->IgnoreArg_pxTaskBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Used = 0;
}

void xTaskCreateStatic_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateStatic_CALL_INSTANCE));
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateStatic_CALL_INSTANCE));
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCreateStatic(cmock_call_instance, pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskCreateStatic_CMockReturnMemThruPtr_pvParameters(UNITY_LINE_TYPE cmock_line, void const* pvParameters, size_t cmock_size)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvParameters_Val = pvParameters;
  cmock_call_instance->ReturnThruPtr_pvParameters_Size = cmock_size;
}

void xTaskCreateStatic_CMockReturnMemThruPtr_puxStackBuffer(UNITY_LINE_TYPE cmock_line, StackType_t const* puxStackBuffer, size_t cmock_size)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_puxStackBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_puxStackBuffer_Val = puxStackBuffer;
  cmock_call_instance->ReturnThruPtr_puxStackBuffer_Size = cmock_size;
}

void xTaskCreateStatic_CMockReturnMemThruPtr_pxTaskBuffer(UNITY_LINE_TYPE cmock_line, StaticTask_t const* pxTaskBuffer, size_t cmock_size)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Val = pxTaskBuffer;
  cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Size = cmock_size;
}

void xTaskCreateStatic_CMockIgnoreArg_pxTaskCode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskCode = 1;
}

void xTaskCreateStatic_CMockIgnoreArg_pcName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcName = 1;
}

void xTaskCreateStatic_CMockIgnoreArg_uxStackDepth(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxStackDepth = 1;
}

void xTaskCreateStatic_CMockIgnoreArg_pvParameters(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameters = 1;
}

void xTaskCreateStatic_CMockIgnoreArg_uxPriority(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxPriority = 1;
}

void xTaskCreateStatic_CMockIgnoreArg_puxStackBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_puxStackBuffer = 1;
}

void xTaskCreateStatic_CMockIgnoreArg_pxTaskBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskBuffer = 1;
}

TaskHandle_t xTaskCreateStaticAffinitySet(TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer, UBaseType_t uxCoreAffinityMask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateStaticAffinitySet);
  cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateStaticAffinitySet_CallInstance);
  Mock.xTaskCreateStaticAffinitySet_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateStaticAffinitySet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskCode)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStaticAffinitySet,CMockString_pxTaskCode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode), sizeof(TaskFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pcName)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStaticAffinitySet,CMockString_pcName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcName, pcName, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxStackDepth)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStaticAffinitySet,CMockString_uxStackDepth);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxStackDepth), (void*)(&uxStackDepth), sizeof(configSTACK_DEPTH_TYPE), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameters)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStaticAffinitySet,CMockString_pvParameters);
    if (cmock_call_instance->Expected_pvParameters == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameters, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameters, pvParameters, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxPriority)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStaticAffinitySet,CMockString_uxPriority);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_puxStackBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStaticAffinitySet,CMockString_puxStackBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_puxStackBuffer), (void*)(puxStackBuffer), sizeof(StackType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxTaskBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStaticAffinitySet,CMockString_pxTaskBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskBuffer), (void*)(pxTaskBuffer), sizeof(StaticTask_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxCoreAffinityMask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStaticAffinitySet,CMockString_uxCoreAffinityMask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pvParameters_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvParameters, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvParameters, (const void*)cmock_call_instance->ReturnThruPtr_pvParameters_Val,
      cmock_call_instance->ReturnThruPtr_pvParameters_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_puxStackBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(puxStackBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)puxStackBuffer, (const void*)cmock_call_instance->ReturnThruPtr_puxStackBuffer_Val,
      cmock_call_instance->ReturnThruPtr_puxStackBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTaskBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTaskBuffer, (const void*)cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateStaticAffinitySet(CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer, UBaseType_t uxCoreAffinityMask);
void CMockExpectParameters_xTaskCreateStaticAffinitySet(CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer, UBaseType_t uxCoreAffinityMask)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode),
         sizeof(TaskFunction_t[sizeof(pxTaskCode) == sizeof(TaskFunction_t) ? 1 : -1])); /* add TaskFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxTaskCode = 0;
  cmock_call_instance->Expected_pcName = pcName;
  cmock_call_instance->IgnoreArg_pcName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxStackDepth), (void*)(&uxStackDepth),
         sizeof(configSTACK_DEPTH_TYPE[sizeof(uxStackDepth) == sizeof(configSTACK_DEPTH_TYPE) ? 1 : -1])); /* add configSTACK_DEPTH_TYPE to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxStackDepth = 0;
  cmock_call_instance->Expected_pvParameters = pvParameters;
  cmock_call_instance->IgnoreArg_pvParameters = 0;
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority),
         sizeof(UBaseType_t[sizeof(uxPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxPriority = 0;
  cmock_call_instance->Expected_puxStackBuffer = puxStackBuffer;
  cmock_call_instance->IgnoreArg_puxStackBuffer = 0;
  cmock_call_instance->ReturnThruPtr_puxStackBuffer_Used = 0;
  cmock_call_instance->Expected_pxTaskBuffer = pxTaskBuffer;
  cmock_call_instance->IgnoreArg_pxTaskBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask),
         sizeof(UBaseType_t[sizeof(uxCoreAffinityMask) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 0;
}

void xTaskCreateStaticAffinitySet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE));
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateStaticAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateStaticAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCreateStaticAffinitySet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE uxStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer, UBaseType_t uxCoreAffinityMask, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE));
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateStaticAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateStaticAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCreateStaticAffinitySet(cmock_call_instance, pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer, uxCoreAffinityMask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskCreateStaticAffinitySet_CMockReturnMemThruPtr_pvParameters(UNITY_LINE_TYPE cmock_line, void const* pvParameters, size_t cmock_size)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvParameters_Val = pvParameters;
  cmock_call_instance->ReturnThruPtr_pvParameters_Size = cmock_size;
}

void xTaskCreateStaticAffinitySet_CMockReturnMemThruPtr_puxStackBuffer(UNITY_LINE_TYPE cmock_line, StackType_t const* puxStackBuffer, size_t cmock_size)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_puxStackBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_puxStackBuffer_Val = puxStackBuffer;
  cmock_call_instance->ReturnThruPtr_puxStackBuffer_Size = cmock_size;
}

void xTaskCreateStaticAffinitySet_CMockReturnMemThruPtr_pxTaskBuffer(UNITY_LINE_TYPE cmock_line, StaticTask_t const* pxTaskBuffer, size_t cmock_size)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Val = pxTaskBuffer;
  cmock_call_instance->ReturnThruPtr_pxTaskBuffer_Size = cmock_size;
}

void xTaskCreateStaticAffinitySet_CMockIgnoreArg_pxTaskCode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskCode = 1;
}

void xTaskCreateStaticAffinitySet_CMockIgnoreArg_pcName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcName = 1;
}

void xTaskCreateStaticAffinitySet_CMockIgnoreArg_uxStackDepth(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxStackDepth = 1;
}

void xTaskCreateStaticAffinitySet_CMockIgnoreArg_pvParameters(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameters = 1;
}

void xTaskCreateStaticAffinitySet_CMockIgnoreArg_uxPriority(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxPriority = 1;
}

void xTaskCreateStaticAffinitySet_CMockIgnoreArg_puxStackBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_puxStackBuffer = 1;
}

void xTaskCreateStaticAffinitySet_CMockIgnoreArg_pxTaskBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskBuffer = 1;
}

void xTaskCreateStaticAffinitySet_CMockIgnoreArg_uxCoreAffinityMask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 1;
}

BaseType_t xTaskCreateRestricted(const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateRestricted);
  cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateRestricted_CallInstance);
  Mock.xTaskCreateRestricted_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateRestricted_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskDefinition)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestricted,CMockString_pxTaskDefinition);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskDefinition), (void*)(pxTaskDefinition), sizeof(const TaskParameters_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxCreatedTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestricted,CMockString_pxCreatedTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxCreatedTask, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxCreatedTask, (const void*)cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val,
      cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateRestricted(CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask);
void CMockExpectParameters_xTaskCreateRestricted(CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask)
{
  cmock_call_instance->Expected_pxTaskDefinition = pxTaskDefinition;
  cmock_call_instance->IgnoreArg_pxTaskDefinition = 0;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->IgnoreArg_pxCreatedTask = 0;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 0;
}

void xTaskCreateRestricted_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestricted_CALL_INSTANCE));
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestricted_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCreateRestricted_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestricted_CALL_INSTANCE));
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestricted_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCreateRestricted(cmock_call_instance, pxTaskDefinition, pxCreatedTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreateRestricted_CMockReturnMemThruPtr_pxCreatedTask(UNITY_LINE_TYPE cmock_line, TaskHandle_t const* pxCreatedTask, size_t cmock_size)
{
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val = pxCreatedTask;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size = cmock_size;
}

void xTaskCreateRestricted_CMockIgnoreArg_pxTaskDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskDefinition = 1;
}

void xTaskCreateRestricted_CMockIgnoreArg_pxCreatedTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCreatedTask = 1;
}

BaseType_t xTaskCreateRestrictedAffinitySet(const TaskParameters_t* const pxTaskDefinition, UBaseType_t uxCoreAffinityMask, TaskHandle_t* pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateRestrictedAffinitySet);
  cmock_call_instance = (CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateRestrictedAffinitySet_CallInstance);
  Mock.xTaskCreateRestrictedAffinitySet_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateRestrictedAffinitySet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskDefinition)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedAffinitySet,CMockString_pxTaskDefinition);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskDefinition), (void*)(pxTaskDefinition), sizeof(const TaskParameters_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxCoreAffinityMask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedAffinitySet,CMockString_uxCoreAffinityMask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxCreatedTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedAffinitySet,CMockString_pxCreatedTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxCreatedTask, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxCreatedTask, (const void*)cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val,
      cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateRestrictedAffinitySet(CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, UBaseType_t uxCoreAffinityMask, TaskHandle_t* pxCreatedTask);
void CMockExpectParameters_xTaskCreateRestrictedAffinitySet(CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, UBaseType_t uxCoreAffinityMask, TaskHandle_t* pxCreatedTask)
{
  cmock_call_instance->Expected_pxTaskDefinition = pxTaskDefinition;
  cmock_call_instance->IgnoreArg_pxTaskDefinition = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask),
         sizeof(UBaseType_t[sizeof(uxCoreAffinityMask) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 0;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->IgnoreArg_pxCreatedTask = 0;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 0;
}

void xTaskCreateRestrictedAffinitySet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE));
  CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestrictedAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestrictedAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCreateRestrictedAffinitySet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskParameters_t* const pxTaskDefinition, UBaseType_t uxCoreAffinityMask, TaskHandle_t* pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE));
  CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestrictedAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestrictedAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCreateRestrictedAffinitySet(cmock_call_instance, pxTaskDefinition, uxCoreAffinityMask, pxCreatedTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreateRestrictedAffinitySet_CMockReturnMemThruPtr_pxCreatedTask(UNITY_LINE_TYPE cmock_line, TaskHandle_t const* pxCreatedTask, size_t cmock_size)
{
  CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val = pxCreatedTask;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size = cmock_size;
}

void xTaskCreateRestrictedAffinitySet_CMockIgnoreArg_pxTaskDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskDefinition = 1;
}

void xTaskCreateRestrictedAffinitySet_CMockIgnoreArg_uxCoreAffinityMask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 1;
}

void xTaskCreateRestrictedAffinitySet_CMockIgnoreArg_pxCreatedTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCreatedTask = 1;
}

BaseType_t xTaskCreateRestrictedStatic(const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateRestrictedStatic);
  cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateRestrictedStatic_CallInstance);
  Mock.xTaskCreateRestrictedStatic_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateRestrictedStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskDefinition)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedStatic,CMockString_pxTaskDefinition);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskDefinition), (void*)(pxTaskDefinition), sizeof(const TaskParameters_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxCreatedTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedStatic,CMockString_pxCreatedTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxCreatedTask, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxCreatedTask, (const void*)cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val,
      cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateRestrictedStatic(CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask);
void CMockExpectParameters_xTaskCreateRestrictedStatic(CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask)
{
  cmock_call_instance->Expected_pxTaskDefinition = pxTaskDefinition;
  cmock_call_instance->IgnoreArg_pxTaskDefinition = 0;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->IgnoreArg_pxCreatedTask = 0;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 0;
}

void xTaskCreateRestrictedStatic_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE));
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestrictedStatic_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestrictedStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCreateRestrictedStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE));
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestrictedStatic_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestrictedStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCreateRestrictedStatic(cmock_call_instance, pxTaskDefinition, pxCreatedTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreateRestrictedStatic_CMockReturnMemThruPtr_pxCreatedTask(UNITY_LINE_TYPE cmock_line, TaskHandle_t const* pxCreatedTask, size_t cmock_size)
{
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val = pxCreatedTask;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size = cmock_size;
}

void xTaskCreateRestrictedStatic_CMockIgnoreArg_pxTaskDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskDefinition = 1;
}

void xTaskCreateRestrictedStatic_CMockIgnoreArg_pxCreatedTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCreatedTask = 1;
}

BaseType_t xTaskCreateRestrictedStaticAffinitySet(const TaskParameters_t* const pxTaskDefinition, UBaseType_t uxCoreAffinityMask, TaskHandle_t* pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateRestrictedStaticAffinitySet);
  cmock_call_instance = (CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance);
  Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskDefinition)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedStaticAffinitySet,CMockString_pxTaskDefinition);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskDefinition), (void*)(pxTaskDefinition), sizeof(const TaskParameters_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxCoreAffinityMask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedStaticAffinitySet,CMockString_uxCoreAffinityMask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxCreatedTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedStaticAffinitySet,CMockString_pxCreatedTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxCreatedTask, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxCreatedTask, (const void*)cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val,
      cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateRestrictedStaticAffinitySet(CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, UBaseType_t uxCoreAffinityMask, TaskHandle_t* pxCreatedTask);
void CMockExpectParameters_xTaskCreateRestrictedStaticAffinitySet(CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, UBaseType_t uxCoreAffinityMask, TaskHandle_t* pxCreatedTask)
{
  cmock_call_instance->Expected_pxTaskDefinition = pxTaskDefinition;
  cmock_call_instance->IgnoreArg_pxTaskDefinition = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask),
         sizeof(UBaseType_t[sizeof(uxCoreAffinityMask) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 0;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->IgnoreArg_pxCreatedTask = 0;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 0;
}

void xTaskCreateRestrictedStaticAffinitySet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE));
  CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCreateRestrictedStaticAffinitySet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskParameters_t* const pxTaskDefinition, UBaseType_t uxCoreAffinityMask, TaskHandle_t* pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE));
  CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCreateRestrictedStaticAffinitySet(cmock_call_instance, pxTaskDefinition, uxCoreAffinityMask, pxCreatedTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreateRestrictedStaticAffinitySet_CMockReturnMemThruPtr_pxCreatedTask(UNITY_LINE_TYPE cmock_line, TaskHandle_t const* pxCreatedTask, size_t cmock_size)
{
  CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val = pxCreatedTask;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size = cmock_size;
}

void xTaskCreateRestrictedStaticAffinitySet_CMockIgnoreArg_pxTaskDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskDefinition = 1;
}

void xTaskCreateRestrictedStaticAffinitySet_CMockIgnoreArg_uxCoreAffinityMask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 1;
}

void xTaskCreateRestrictedStaticAffinitySet_CMockIgnoreArg_pxCreatedTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStaticAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreateRestrictedStaticAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCreatedTask = 1;
}

void vTaskAllocateMPURegions(TaskHandle_t xTaskToModify, const MemoryRegion_t* const pxRegions)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskAllocateMPURegions);
  cmock_call_instance = (CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskAllocateMPURegions_CallInstance);
  Mock.vTaskAllocateMPURegions_CallInstance = CMock_Guts_MemNext(Mock.vTaskAllocateMPURegions_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToModify)
  {
    UNITY_SET_DETAILS(CMockString_vTaskAllocateMPURegions,CMockString_xTaskToModify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToModify), (void*)(&xTaskToModify), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxRegions)
  {
    UNITY_SET_DETAILS(CMockString_vTaskAllocateMPURegions,CMockString_pxRegions);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxRegions), (void*)(pxRegions), sizeof(const MemoryRegion_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskAllocateMPURegions(CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToModify, const MemoryRegion_t* const pxRegions);
void CMockExpectParameters_vTaskAllocateMPURegions(CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToModify, const MemoryRegion_t* const pxRegions)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToModify), (void*)(&xTaskToModify),
         sizeof(TaskHandle_t[sizeof(xTaskToModify) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToModify = 0;
  cmock_call_instance->Expected_pxRegions = pxRegions;
  cmock_call_instance->IgnoreArg_pxRegions = 0;
}

void vTaskAllocateMPURegions_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE));
  CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskAllocateMPURegions_CallInstance = CMock_Guts_MemChain(Mock.vTaskAllocateMPURegions_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskAllocateMPURegions_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToModify, const MemoryRegion_t* const pxRegions)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE));
  CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskAllocateMPURegions_CallInstance = CMock_Guts_MemChain(Mock.vTaskAllocateMPURegions_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskAllocateMPURegions(cmock_call_instance, xTaskToModify, pxRegions);
}

void vTaskAllocateMPURegions_CMockIgnoreArg_xTaskToModify(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskAllocateMPURegions_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToModify = 1;
}

void vTaskAllocateMPURegions_CMockIgnoreArg_pxRegions(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskAllocateMPURegions_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxRegions = 1;
}

void vTaskDelete(TaskHandle_t xTaskToDelete)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskDelete);
  cmock_call_instance = (CMOCK_vTaskDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskDelete_CallInstance);
  Mock.vTaskDelete_CallInstance = CMock_Guts_MemNext(Mock.vTaskDelete_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToDelete)
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelete,CMockString_xTaskToDelete);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToDelete), (void*)(&xTaskToDelete), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskDelete(CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToDelete);
void CMockExpectParameters_vTaskDelete(CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToDelete)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToDelete), (void*)(&xTaskToDelete),
         sizeof(TaskHandle_t[sizeof(xTaskToDelete) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToDelete = 0;
}

void vTaskDelete_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelete_CALL_INSTANCE));
  CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelete_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskDelete_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToDelete)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelete_CALL_INSTANCE));
  CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelete_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskDelete(cmock_call_instance, xTaskToDelete);
}

void vTaskDelete_CMockIgnoreArg_xTaskToDelete(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskDelete_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToDelete = 1;
}

void vTaskDelay(const TickType_t xTicksToDelay)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskDelay);
  cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskDelay_CallInstance);
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemNext(Mock.vTaskDelay_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTicksToDelay)
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelay,CMockString_xTicksToDelay);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToDelay), (void*)(&xTicksToDelay), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskDelay(CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance, const TickType_t xTicksToDelay);
void CMockExpectParameters_vTaskDelay(CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance, const TickType_t xTicksToDelay)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToDelay), (void*)(&xTicksToDelay),
         sizeof(TickType_t[sizeof(xTicksToDelay) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToDelay = 0;
}

void vTaskDelay_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelay_CALL_INSTANCE));
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskDelay_CMockExpect(UNITY_LINE_TYPE cmock_line, const TickType_t xTicksToDelay)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelay_CALL_INSTANCE));
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskDelay(cmock_call_instance, xTicksToDelay);
}

void vTaskDelay_CMockIgnoreArg_xTicksToDelay(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskDelay_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToDelay = 1;
}

BaseType_t xTaskDelayUntil(TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskDelayUntil_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskDelayUntil);
  cmock_call_instance = (CMOCK_xTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskDelayUntil_CallInstance);
  Mock.xTaskDelayUntil_CallInstance = CMock_Guts_MemNext(Mock.xTaskDelayUntil_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxPreviousWakeTime)
  {
    UNITY_SET_DETAILS(CMockString_xTaskDelayUntil,CMockString_pxPreviousWakeTime);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxPreviousWakeTime), (void*)(pxPreviousWakeTime), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTimeIncrement)
  {
    UNITY_SET_DETAILS(CMockString_xTaskDelayUntil,CMockString_xTimeIncrement);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimeIncrement), (void*)(&xTimeIncrement), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxPreviousWakeTime, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxPreviousWakeTime, (const void*)cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Val,
      cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskDelayUntil(CMOCK_xTaskDelayUntil_CALL_INSTANCE* cmock_call_instance, TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement);
void CMockExpectParameters_xTaskDelayUntil(CMOCK_xTaskDelayUntil_CALL_INSTANCE* cmock_call_instance, TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
  cmock_call_instance->Expected_pxPreviousWakeTime = pxPreviousWakeTime;
  cmock_call_instance->IgnoreArg_pxPreviousWakeTime = 0;
  cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTimeIncrement), (void*)(&xTimeIncrement),
         sizeof(TickType_t[sizeof(xTimeIncrement) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimeIncrement = 0;
}

void xTaskDelayUntil_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskDelayUntil_CALL_INSTANCE));
  CMOCK_xTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.xTaskDelayUntil_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskDelayUntil_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskDelayUntil_CALL_INSTANCE));
  CMOCK_xTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.xTaskDelayUntil_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskDelayUntil(cmock_call_instance, pxPreviousWakeTime, xTimeIncrement);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskDelayUntil_CMockReturnMemThruPtr_pxPreviousWakeTime(UNITY_LINE_TYPE cmock_line, TickType_t const* pxPreviousWakeTime, size_t cmock_size)
{
  CMOCK_xTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskDelayUntil_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Val = pxPreviousWakeTime;
  cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Size = cmock_size;
}

void xTaskDelayUntil_CMockIgnoreArg_pxPreviousWakeTime(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskDelayUntil_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxPreviousWakeTime = 1;
}

void xTaskDelayUntil_CMockIgnoreArg_xTimeIncrement(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskDelayUntil_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimeIncrement = 1;
}

BaseType_t xTaskAbortDelay(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskAbortDelay);
  cmock_call_instance = (CMOCK_xTaskAbortDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskAbortDelay_CallInstance);
  Mock.xTaskAbortDelay_CallInstance = CMock_Guts_MemNext(Mock.xTaskAbortDelay_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskAbortDelay,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskAbortDelay(CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask);
void CMockExpectParameters_xTaskAbortDelay(CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void xTaskAbortDelay_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskAbortDelay_CALL_INSTANCE));
  CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskAbortDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskAbortDelay_CallInstance = CMock_Guts_MemChain(Mock.xTaskAbortDelay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskAbortDelay_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskAbortDelay_CALL_INSTANCE));
  CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskAbortDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskAbortDelay_CallInstance = CMock_Guts_MemChain(Mock.xTaskAbortDelay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskAbortDelay(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskAbortDelay_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskAbortDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskAbortDelay_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

UBaseType_t uxTaskPriorityGet(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskPriorityGet);
  cmock_call_instance = (CMOCK_uxTaskPriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskPriorityGet_CallInstance);
  Mock.uxTaskPriorityGet_CallInstance = CMock_Guts_MemNext(Mock.uxTaskPriorityGet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskPriorityGet,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskPriorityGet(CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask);
void CMockExpectParameters_uxTaskPriorityGet(CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void uxTaskPriorityGet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskPriorityGet_CALL_INSTANCE));
  CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskPriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskPriorityGet_CallInstance = CMock_Guts_MemChain(Mock.uxTaskPriorityGet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTaskPriorityGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskPriorityGet_CALL_INSTANCE));
  CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskPriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskPriorityGet_CallInstance = CMock_Guts_MemChain(Mock.uxTaskPriorityGet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTaskPriorityGet(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTaskPriorityGet_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskPriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskPriorityGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

UBaseType_t uxTaskPriorityGetFromISR(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskPriorityGetFromISR);
  cmock_call_instance = (CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskPriorityGetFromISR_CallInstance);
  Mock.uxTaskPriorityGetFromISR_CallInstance = CMock_Guts_MemNext(Mock.uxTaskPriorityGetFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskPriorityGetFromISR,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskPriorityGetFromISR(CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask);
void CMockExpectParameters_uxTaskPriorityGetFromISR(CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void uxTaskPriorityGetFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE));
  CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskPriorityGetFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxTaskPriorityGetFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTaskPriorityGetFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE));
  CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskPriorityGetFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxTaskPriorityGetFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTaskPriorityGetFromISR(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTaskPriorityGetFromISR_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskPriorityGetFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

UBaseType_t uxTaskBasePriorityGet(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskBasePriorityGet);
  cmock_call_instance = (CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskBasePriorityGet_CallInstance);
  Mock.uxTaskBasePriorityGet_CallInstance = CMock_Guts_MemNext(Mock.uxTaskBasePriorityGet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskBasePriorityGet,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskBasePriorityGet(CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask);
void CMockExpectParameters_uxTaskBasePriorityGet(CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void uxTaskBasePriorityGet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE));
  CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskBasePriorityGet_CallInstance = CMock_Guts_MemChain(Mock.uxTaskBasePriorityGet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTaskBasePriorityGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE));
  CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskBasePriorityGet_CallInstance = CMock_Guts_MemChain(Mock.uxTaskBasePriorityGet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTaskBasePriorityGet(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTaskBasePriorityGet_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskBasePriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskBasePriorityGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

UBaseType_t uxTaskBasePriorityGetFromISR(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskBasePriorityGetFromISR);
  cmock_call_instance = (CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskBasePriorityGetFromISR_CallInstance);
  Mock.uxTaskBasePriorityGetFromISR_CallInstance = CMock_Guts_MemNext(Mock.uxTaskBasePriorityGetFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskBasePriorityGetFromISR,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskBasePriorityGetFromISR(CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask);
void CMockExpectParameters_uxTaskBasePriorityGetFromISR(CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void uxTaskBasePriorityGetFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE));
  CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskBasePriorityGetFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxTaskBasePriorityGetFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTaskBasePriorityGetFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE));
  CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskBasePriorityGetFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxTaskBasePriorityGetFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTaskBasePriorityGetFromISR(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTaskBasePriorityGetFromISR_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskBasePriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskBasePriorityGetFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

eTaskState eTaskGetState(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_eTaskGetState);
  cmock_call_instance = (CMOCK_eTaskGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.eTaskGetState_CallInstance);
  Mock.eTaskGetState_CallInstance = CMock_Guts_MemNext(Mock.eTaskGetState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_eTaskGetState,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_eTaskGetState(CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask);
void CMockExpectParameters_eTaskGetState(CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void eTaskGetState_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, eTaskState cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eTaskGetState_CALL_INSTANCE));
  CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_eTaskGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eTaskGetState_CallInstance = CMock_Guts_MemChain(Mock.eTaskGetState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void eTaskGetState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, eTaskState cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eTaskGetState_CALL_INSTANCE));
  CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_eTaskGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eTaskGetState_CallInstance = CMock_Guts_MemChain(Mock.eTaskGetState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_eTaskGetState(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eTaskState[sizeof(cmock_to_return) == sizeof(eTaskState) ? 1 : -1])); /* add eTaskState to :treat_as_array if this causes an error */
}

void eTaskGetState_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_eTaskGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eTaskGetState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t* pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskGetInfo);
  cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskGetInfo_CallInstance);
  Mock.vTaskGetInfo_CallInstance = CMock_Guts_MemNext(Mock.vTaskGetInfo_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetInfo,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxTaskStatus)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetInfo,CMockString_pxTaskStatus);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskStatus), (void*)(pxTaskStatus), sizeof(TaskStatus_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xGetFreeStackSpace)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetInfo,CMockString_xGetFreeStackSpace);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xGetFreeStackSpace), (void*)(&xGetFreeStackSpace), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_eState)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetInfo,CMockString_eState);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eState), (void*)(&eState), sizeof(eTaskState), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxTaskStatus_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTaskStatus, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTaskStatus, (const void*)cmock_call_instance->ReturnThruPtr_pxTaskStatus_Val,
      cmock_call_instance->ReturnThruPtr_pxTaskStatus_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskGetInfo(CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, TaskStatus_t* pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState);
void CMockExpectParameters_vTaskGetInfo(CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, TaskStatus_t* pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  cmock_call_instance->Expected_pxTaskStatus = pxTaskStatus;
  cmock_call_instance->IgnoreArg_pxTaskStatus = 0;
  cmock_call_instance->ReturnThruPtr_pxTaskStatus_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xGetFreeStackSpace), (void*)(&xGetFreeStackSpace),
         sizeof(BaseType_t[sizeof(xGetFreeStackSpace) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xGetFreeStackSpace = 0;
  memcpy((void*)(&cmock_call_instance->Expected_eState), (void*)(&eState),
         sizeof(eTaskState[sizeof(eState) == sizeof(eTaskState) ? 1 : -1])); /* add eTaskState to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eState = 0;
}

void vTaskGetInfo_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGetInfo_CALL_INSTANCE));
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGetInfo_CallInstance = CMock_Guts_MemChain(Mock.vTaskGetInfo_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskGetInfo_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskStatus_t* pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGetInfo_CALL_INSTANCE));
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGetInfo_CallInstance = CMock_Guts_MemChain(Mock.vTaskGetInfo_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskGetInfo(cmock_call_instance, xTask, pxTaskStatus, xGetFreeStackSpace, eState);
}

void vTaskGetInfo_CMockReturnMemThruPtr_pxTaskStatus(UNITY_LINE_TYPE cmock_line, TaskStatus_t const* pxTaskStatus, size_t cmock_size)
{
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGetInfo_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTaskStatus_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTaskStatus_Val = pxTaskStatus;
  cmock_call_instance->ReturnThruPtr_pxTaskStatus_Size = cmock_size;
}

void vTaskGetInfo_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGetInfo_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskGetInfo_CMockIgnoreArg_pxTaskStatus(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGetInfo_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskStatus = 1;
}

void vTaskGetInfo_CMockIgnoreArg_xGetFreeStackSpace(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGetInfo_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xGetFreeStackSpace = 1;
}

void vTaskGetInfo_CMockIgnoreArg_eState(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGetInfo_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eState = 1;
}

void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPrioritySet);
  cmock_call_instance = (CMOCK_vTaskPrioritySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPrioritySet_CallInstance);
  Mock.vTaskPrioritySet_CallInstance = CMock_Guts_MemNext(Mock.vTaskPrioritySet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPrioritySet,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxNewPriority)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPrioritySet,CMockString_uxNewPriority);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxNewPriority), (void*)(&uxNewPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPrioritySet(CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, UBaseType_t uxNewPriority);
void CMockExpectParameters_vTaskPrioritySet(CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxNewPriority), (void*)(&uxNewPriority),
         sizeof(UBaseType_t[sizeof(uxNewPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxNewPriority = 0;
}

void vTaskPrioritySet_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPrioritySet_CALL_INSTANCE));
  CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPrioritySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPrioritySet_CallInstance = CMock_Guts_MemChain(Mock.vTaskPrioritySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskPrioritySet_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPrioritySet_CALL_INSTANCE));
  CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPrioritySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPrioritySet_CallInstance = CMock_Guts_MemChain(Mock.vTaskPrioritySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskPrioritySet(cmock_call_instance, xTask, uxNewPriority);
}

void vTaskPrioritySet_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPrioritySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPrioritySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskPrioritySet_CMockIgnoreArg_uxNewPriority(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPrioritySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPrioritySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxNewPriority = 1;
}

void vTaskSuspend(TaskHandle_t xTaskToSuspend)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSuspend);
  cmock_call_instance = (CMOCK_vTaskSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSuspend_CallInstance);
  Mock.vTaskSuspend_CallInstance = CMock_Guts_MemNext(Mock.vTaskSuspend_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToSuspend)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSuspend,CMockString_xTaskToSuspend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToSuspend), (void*)(&xTaskToSuspend), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSuspend(CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToSuspend);
void CMockExpectParameters_vTaskSuspend(CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToSuspend)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToSuspend), (void*)(&xTaskToSuspend),
         sizeof(TaskHandle_t[sizeof(xTaskToSuspend) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToSuspend = 0;
}

void vTaskSuspend_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSuspend_CALL_INSTANCE));
  CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSuspend_CallInstance = CMock_Guts_MemChain(Mock.vTaskSuspend_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskSuspend_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToSuspend)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSuspend_CALL_INSTANCE));
  CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSuspend_CallInstance = CMock_Guts_MemChain(Mock.vTaskSuspend_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskSuspend(cmock_call_instance, xTaskToSuspend);
}

void vTaskSuspend_CMockIgnoreArg_xTaskToSuspend(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSuspend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToSuspend = 1;
}

void vTaskResume(TaskHandle_t xTaskToResume)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskResume);
  cmock_call_instance = (CMOCK_vTaskResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskResume_CallInstance);
  Mock.vTaskResume_CallInstance = CMock_Guts_MemNext(Mock.vTaskResume_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToResume)
  {
    UNITY_SET_DETAILS(CMockString_vTaskResume,CMockString_xTaskToResume);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToResume), (void*)(&xTaskToResume), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskResume(CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToResume);
void CMockExpectParameters_vTaskResume(CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToResume)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToResume), (void*)(&xTaskToResume),
         sizeof(TaskHandle_t[sizeof(xTaskToResume) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToResume = 0;
}

void vTaskResume_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskResume_CALL_INSTANCE));
  CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskResume_CallInstance = CMock_Guts_MemChain(Mock.vTaskResume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskResume_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToResume)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskResume_CALL_INSTANCE));
  CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskResume_CallInstance = CMock_Guts_MemChain(Mock.vTaskResume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskResume(cmock_call_instance, xTaskToResume);
}

void vTaskResume_CMockIgnoreArg_xTaskToResume(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskResume_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToResume = 1;
}

BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskResumeFromISR);
  cmock_call_instance = (CMOCK_xTaskResumeFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskResumeFromISR_CallInstance);
  Mock.xTaskResumeFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskResumeFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToResume)
  {
    UNITY_SET_DETAILS(CMockString_xTaskResumeFromISR,CMockString_xTaskToResume);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToResume), (void*)(&xTaskToResume), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskResumeFromISR(CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToResume);
void CMockExpectParameters_xTaskResumeFromISR(CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToResume)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToResume), (void*)(&xTaskToResume),
         sizeof(TaskHandle_t[sizeof(xTaskToResume) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToResume = 0;
}

void xTaskResumeFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskResumeFromISR_CALL_INSTANCE));
  CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskResumeFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskResumeFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskResumeFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskResumeFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToResume, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskResumeFromISR_CALL_INSTANCE));
  CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskResumeFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskResumeFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskResumeFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskResumeFromISR(cmock_call_instance, xTaskToResume);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskResumeFromISR_CMockIgnoreArg_xTaskToResume(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskResumeFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskResumeFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToResume = 1;
}

void vTaskCoreAffinitySet(const TaskHandle_t xTask, UBaseType_t uxCoreAffinityMask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskCoreAffinitySet);
  cmock_call_instance = (CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskCoreAffinitySet_CallInstance);
  Mock.vTaskCoreAffinitySet_CallInstance = CMock_Guts_MemNext(Mock.vTaskCoreAffinitySet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskCoreAffinitySet,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxCoreAffinityMask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskCoreAffinitySet,CMockString_uxCoreAffinityMask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskCoreAffinitySet(CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask, UBaseType_t uxCoreAffinityMask);
void CMockExpectParameters_vTaskCoreAffinitySet(CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask, UBaseType_t uxCoreAffinityMask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxCoreAffinityMask), (void*)(&uxCoreAffinityMask),
         sizeof(UBaseType_t[sizeof(uxCoreAffinityMask) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 0;
}

void vTaskCoreAffinitySet_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE));
  CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskCoreAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.vTaskCoreAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskCoreAffinitySet_CMockExpect(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, UBaseType_t uxCoreAffinityMask)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE));
  CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskCoreAffinitySet_CallInstance = CMock_Guts_MemChain(Mock.vTaskCoreAffinitySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskCoreAffinitySet(cmock_call_instance, xTask, uxCoreAffinityMask);
}

void vTaskCoreAffinitySet_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskCoreAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskCoreAffinitySet_CMockIgnoreArg_uxCoreAffinityMask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskCoreAffinitySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskCoreAffinitySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxCoreAffinityMask = 1;
}

UBaseType_t vTaskCoreAffinityGet(ConstTaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskCoreAffinityGet);
  cmock_call_instance = (CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskCoreAffinityGet_CallInstance);
  Mock.vTaskCoreAffinityGet_CallInstance = CMock_Guts_MemNext(Mock.vTaskCoreAffinityGet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskCoreAffinityGet,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(ConstTaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_vTaskCoreAffinityGet(CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE* cmock_call_instance, ConstTaskHandle_t xTask);
void CMockExpectParameters_vTaskCoreAffinityGet(CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE* cmock_call_instance, ConstTaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(ConstTaskHandle_t[sizeof(xTask) == sizeof(ConstTaskHandle_t) ? 1 : -1])); /* add ConstTaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void vTaskCoreAffinityGet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE));
  CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskCoreAffinityGet_CallInstance = CMock_Guts_MemChain(Mock.vTaskCoreAffinityGet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskCoreAffinityGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ConstTaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE));
  CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskCoreAffinityGet_CallInstance = CMock_Guts_MemChain(Mock.vTaskCoreAffinityGet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskCoreAffinityGet(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vTaskCoreAffinityGet_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskCoreAffinityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskCoreAffinityGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskPreemptionDisable(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPreemptionDisable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPreemptionDisable);
  cmock_call_instance = (CMOCK_vTaskPreemptionDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPreemptionDisable_CallInstance);
  Mock.vTaskPreemptionDisable_CallInstance = CMock_Guts_MemNext(Mock.vTaskPreemptionDisable_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPreemptionDisable,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPreemptionDisable(CMOCK_vTaskPreemptionDisable_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask);
void CMockExpectParameters_vTaskPreemptionDisable(CMOCK_vTaskPreemptionDisable_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void vTaskPreemptionDisable_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPreemptionDisable_CALL_INSTANCE));
  CMOCK_vTaskPreemptionDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPreemptionDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPreemptionDisable_CallInstance = CMock_Guts_MemChain(Mock.vTaskPreemptionDisable_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskPreemptionDisable_CMockExpect(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPreemptionDisable_CALL_INSTANCE));
  CMOCK_vTaskPreemptionDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPreemptionDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPreemptionDisable_CallInstance = CMock_Guts_MemChain(Mock.vTaskPreemptionDisable_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskPreemptionDisable(cmock_call_instance, xTask);
}

void vTaskPreemptionDisable_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPreemptionDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPreemptionDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPreemptionDisable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskPreemptionEnable(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPreemptionEnable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPreemptionEnable);
  cmock_call_instance = (CMOCK_vTaskPreemptionEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPreemptionEnable_CallInstance);
  Mock.vTaskPreemptionEnable_CallInstance = CMock_Guts_MemNext(Mock.vTaskPreemptionEnable_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPreemptionEnable,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPreemptionEnable(CMOCK_vTaskPreemptionEnable_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask);
void CMockExpectParameters_vTaskPreemptionEnable(CMOCK_vTaskPreemptionEnable_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void vTaskPreemptionEnable_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPreemptionEnable_CALL_INSTANCE));
  CMOCK_vTaskPreemptionEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPreemptionEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPreemptionEnable_CallInstance = CMock_Guts_MemChain(Mock.vTaskPreemptionEnable_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskPreemptionEnable_CMockExpect(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPreemptionEnable_CALL_INSTANCE));
  CMOCK_vTaskPreemptionEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPreemptionEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPreemptionEnable_CallInstance = CMock_Guts_MemChain(Mock.vTaskPreemptionEnable_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskPreemptionEnable(cmock_call_instance, xTask);
}

void vTaskPreemptionEnable_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPreemptionEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPreemptionEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPreemptionEnable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskStartScheduler(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskStartScheduler_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskStartScheduler);
  cmock_call_instance = (CMOCK_vTaskStartScheduler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskStartScheduler_CallInstance);
  Mock.vTaskStartScheduler_CallInstance = CMock_Guts_MemNext(Mock.vTaskStartScheduler_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskStartScheduler_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskStartScheduler_CALL_INSTANCE));
  CMOCK_vTaskStartScheduler_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskStartScheduler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskStartScheduler_CallInstance = CMock_Guts_MemChain(Mock.vTaskStartScheduler_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vTaskEndScheduler(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskEndScheduler_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskEndScheduler);
  cmock_call_instance = (CMOCK_vTaskEndScheduler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskEndScheduler_CallInstance);
  Mock.vTaskEndScheduler_CallInstance = CMock_Guts_MemNext(Mock.vTaskEndScheduler_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskEndScheduler_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskEndScheduler_CALL_INSTANCE));
  CMOCK_vTaskEndScheduler_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskEndScheduler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskEndScheduler_CallInstance = CMock_Guts_MemChain(Mock.vTaskEndScheduler_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vTaskSuspendAll(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSuspendAll_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSuspendAll);
  cmock_call_instance = (CMOCK_vTaskSuspendAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSuspendAll_CallInstance);
  Mock.vTaskSuspendAll_CallInstance = CMock_Guts_MemNext(Mock.vTaskSuspendAll_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskSuspendAll_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSuspendAll_CALL_INSTANCE));
  CMOCK_vTaskSuspendAll_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSuspendAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSuspendAll_CallInstance = CMock_Guts_MemChain(Mock.vTaskSuspendAll_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

BaseType_t xTaskResumeAll(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskResumeAll_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskResumeAll);
  cmock_call_instance = (CMOCK_xTaskResumeAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskResumeAll_CallInstance);
  Mock.xTaskResumeAll_CallInstance = CMock_Guts_MemNext(Mock.xTaskResumeAll_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskResumeAll_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskResumeAll_CALL_INSTANCE));
  CMOCK_xTaskResumeAll_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskResumeAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskResumeAll_CallInstance = CMock_Guts_MemChain(Mock.xTaskResumeAll_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

TickType_t xTaskGetTickCount(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetTickCount_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetTickCount);
  cmock_call_instance = (CMOCK_xTaskGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetTickCount_CallInstance);
  Mock.xTaskGetTickCount_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetTickCount_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetTickCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCount_CALL_INSTANCE));
  CMOCK_xTaskGetTickCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCount_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCount_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

TickType_t xTaskGetTickCountFromISR(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetTickCountFromISR);
  cmock_call_instance = (CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetTickCountFromISR_CallInstance);
  Mock.xTaskGetTickCountFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetTickCountFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetTickCountFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE));
  CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCountFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCountFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

UBaseType_t uxTaskGetNumberOfTasks(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetNumberOfTasks);
  cmock_call_instance = (CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetNumberOfTasks_CallInstance);
  Mock.uxTaskGetNumberOfTasks_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetNumberOfTasks_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void uxTaskGetNumberOfTasks_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE));
  CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetNumberOfTasks_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetNumberOfTasks_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

char* pcTaskGetName(TaskHandle_t xTaskToQuery)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pcTaskGetName);
  cmock_call_instance = (CMOCK_pcTaskGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pcTaskGetName_CallInstance);
  Mock.pcTaskGetName_CallInstance = CMock_Guts_MemNext(Mock.pcTaskGetName_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToQuery)
  {
    UNITY_SET_DETAILS(CMockString_pcTaskGetName,CMockString_xTaskToQuery);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToQuery), (void*)(&xTaskToQuery), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pcTaskGetName(CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToQuery);
void CMockExpectParameters_pcTaskGetName(CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToQuery)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToQuery), (void*)(&xTaskToQuery),
         sizeof(TaskHandle_t[sizeof(xTaskToQuery) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToQuery = 0;
}

void pcTaskGetName_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTaskGetName_CALL_INSTANCE));
  CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTaskGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTaskGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTaskGetName_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void pcTaskGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToQuery, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTaskGetName_CALL_INSTANCE));
  CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTaskGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTaskGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTaskGetName_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_pcTaskGetName(cmock_call_instance, xTaskToQuery);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pcTaskGetName_CMockIgnoreArg_xTaskToQuery(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTaskGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.pcTaskGetName_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToQuery = 1;
}

TaskHandle_t xTaskGetHandle(const char* pcNameToQuery)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetHandle);
  cmock_call_instance = (CMOCK_xTaskGetHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetHandle_CallInstance);
  Mock.xTaskGetHandle_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetHandle_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pcNameToQuery)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetHandle,CMockString_pcNameToQuery);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcNameToQuery, pcNameToQuery, cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetHandle(CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance, const char* pcNameToQuery);
void CMockExpectParameters_xTaskGetHandle(CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance, const char* pcNameToQuery)
{
  cmock_call_instance->Expected_pcNameToQuery = pcNameToQuery;
  cmock_call_instance->IgnoreArg_pcNameToQuery = 0;
}

void xTaskGetHandle_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetHandle_CALL_INSTANCE));
  CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetHandle_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetHandle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGetHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* pcNameToQuery, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetHandle_CALL_INSTANCE));
  CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetHandle_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetHandle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGetHandle(cmock_call_instance, pcNameToQuery);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskGetHandle_CMockIgnoreArg_pcNameToQuery(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetHandle_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcNameToQuery = 1;
}

BaseType_t xTaskGetStaticBuffers(TaskHandle_t xTask, StackType_t** ppuxStackBuffer, StaticTask_t** ppxTaskBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetStaticBuffers);
  cmock_call_instance = (CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetStaticBuffers_CallInstance);
  Mock.xTaskGetStaticBuffers_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetStaticBuffers_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetStaticBuffers,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ppuxStackBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetStaticBuffers,CMockString_ppuxStackBuffer);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppuxStackBuffer, ppuxStackBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ppxTaskBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetStaticBuffers,CMockString_ppxTaskBuffer);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxTaskBuffer, ppxTaskBuffer, cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_ppuxStackBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppuxStackBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppuxStackBuffer, (const void*)cmock_call_instance->ReturnThruPtr_ppuxStackBuffer_Val,
      cmock_call_instance->ReturnThruPtr_ppuxStackBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_ppxTaskBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxTaskBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxTaskBuffer, (const void*)cmock_call_instance->ReturnThruPtr_ppxTaskBuffer_Val,
      cmock_call_instance->ReturnThruPtr_ppxTaskBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetStaticBuffers(CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, StackType_t** ppuxStackBuffer, StaticTask_t** ppxTaskBuffer);
void CMockExpectParameters_xTaskGetStaticBuffers(CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, StackType_t** ppuxStackBuffer, StaticTask_t** ppxTaskBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  cmock_call_instance->Expected_ppuxStackBuffer = ppuxStackBuffer;
  cmock_call_instance->IgnoreArg_ppuxStackBuffer = 0;
  cmock_call_instance->ReturnThruPtr_ppuxStackBuffer_Used = 0;
  cmock_call_instance->Expected_ppxTaskBuffer = ppxTaskBuffer;
  cmock_call_instance->IgnoreArg_ppxTaskBuffer = 0;
  cmock_call_instance->ReturnThruPtr_ppxTaskBuffer_Used = 0;
}

void xTaskGetStaticBuffers_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE));
  CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetStaticBuffers_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetStaticBuffers_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGetStaticBuffers_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, StackType_t** ppuxStackBuffer, StaticTask_t** ppxTaskBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE));
  CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetStaticBuffers_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetStaticBuffers_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGetStaticBuffers(cmock_call_instance, xTask, ppuxStackBuffer, ppxTaskBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskGetStaticBuffers_CMockReturnMemThruPtr_ppuxStackBuffer(UNITY_LINE_TYPE cmock_line, StackType_t* const* ppuxStackBuffer, size_t cmock_size)
{
  CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetStaticBuffers_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppuxStackBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppuxStackBuffer_Val = ppuxStackBuffer;
  cmock_call_instance->ReturnThruPtr_ppuxStackBuffer_Size = cmock_size;
}

void xTaskGetStaticBuffers_CMockReturnMemThruPtr_ppxTaskBuffer(UNITY_LINE_TYPE cmock_line, StaticTask_t* const* ppxTaskBuffer, size_t cmock_size)
{
  CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetStaticBuffers_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxTaskBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxTaskBuffer_Val = ppxTaskBuffer;
  cmock_call_instance->ReturnThruPtr_ppxTaskBuffer_Size = cmock_size;
}

void xTaskGetStaticBuffers_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetStaticBuffers_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void xTaskGetStaticBuffers_CMockIgnoreArg_ppuxStackBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetStaticBuffers_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppuxStackBuffer = 1;
}

void xTaskGetStaticBuffers_CMockIgnoreArg_ppxTaskBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetStaticBuffers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetStaticBuffers_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxTaskBuffer = 1;
}

UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetStackHighWaterMark);
  cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetStackHighWaterMark_CallInstance);
  Mock.uxTaskGetStackHighWaterMark_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetStackHighWaterMark_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetStackHighWaterMark,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskGetStackHighWaterMark(CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask);
void CMockExpectParameters_uxTaskGetStackHighWaterMark(CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void uxTaskGetStackHighWaterMark_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE));
  CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetStackHighWaterMark_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetStackHighWaterMark_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTaskGetStackHighWaterMark_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE));
  CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetStackHighWaterMark_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetStackHighWaterMark_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTaskGetStackHighWaterMark(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTaskGetStackHighWaterMark_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskGetStackHighWaterMark_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetStackHighWaterMark2);
  cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetStackHighWaterMark2_CallInstance);
  Mock.uxTaskGetStackHighWaterMark2_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetStackHighWaterMark2_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetStackHighWaterMark2,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskGetStackHighWaterMark2(CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask);
void CMockExpectParameters_uxTaskGetStackHighWaterMark2(CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void uxTaskGetStackHighWaterMark2_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, configSTACK_DEPTH_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE));
  CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetStackHighWaterMark2_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetStackHighWaterMark2_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTaskGetStackHighWaterMark2_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, configSTACK_DEPTH_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE));
  CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetStackHighWaterMark2_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetStackHighWaterMark2_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTaskGetStackHighWaterMark2(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(configSTACK_DEPTH_TYPE[sizeof(cmock_to_return) == sizeof(configSTACK_DEPTH_TYPE) ? 1 : -1])); /* add configSTACK_DEPTH_TYPE to :treat_as_array if this causes an error */
}

void uxTaskGetStackHighWaterMark2_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskGetStackHighWaterMark2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskSetApplicationTaskTag(TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSetApplicationTaskTag);
  cmock_call_instance = (CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSetApplicationTaskTag_CallInstance);
  Mock.vTaskSetApplicationTaskTag_CallInstance = CMock_Guts_MemNext(Mock.vTaskSetApplicationTaskTag_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetApplicationTaskTag,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHookFunction)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetApplicationTaskTag,CMockString_pxHookFunction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxHookFunction), (void*)(&pxHookFunction), sizeof(TaskHookFunction_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSetApplicationTaskTag(CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, TaskHookFunction_t pxHookFunction);
void CMockExpectParameters_vTaskSetApplicationTaskTag(CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  memcpy((void*)(&cmock_call_instance->Expected_pxHookFunction), (void*)(&pxHookFunction),
         sizeof(TaskHookFunction_t[sizeof(pxHookFunction) == sizeof(TaskHookFunction_t) ? 1 : -1])); /* add TaskHookFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxHookFunction = 0;
}

void vTaskSetApplicationTaskTag_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE));
  CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetApplicationTaskTag_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetApplicationTaskTag_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskSetApplicationTaskTag_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE));
  CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetApplicationTaskTag_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetApplicationTaskTag_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskSetApplicationTaskTag(cmock_call_instance, xTask, pxHookFunction);
}

void vTaskSetApplicationTaskTag_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetApplicationTaskTag_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskSetApplicationTaskTag_CMockIgnoreArg_pxHookFunction(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetApplicationTaskTag_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHookFunction = 1;
}

TaskHookFunction_t xTaskGetApplicationTaskTag(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetApplicationTaskTag);
  cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetApplicationTaskTag_CallInstance);
  Mock.xTaskGetApplicationTaskTag_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetApplicationTaskTag_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetApplicationTaskTag,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetApplicationTaskTag(CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask);
void CMockExpectParameters_xTaskGetApplicationTaskTag(CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void xTaskGetApplicationTaskTag_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHookFunction_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE));
  CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetApplicationTaskTag_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetApplicationTaskTag_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGetApplicationTaskTag_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskHookFunction_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE));
  CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetApplicationTaskTag_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetApplicationTaskTag_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGetApplicationTaskTag(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHookFunction_t[sizeof(cmock_to_return) == sizeof(TaskHookFunction_t) ? 1 : -1])); /* add TaskHookFunction_t to :treat_as_array if this causes an error */
}

void xTaskGetApplicationTaskTag_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetApplicationTaskTag_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

TaskHookFunction_t xTaskGetApplicationTaskTagFromISR(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetApplicationTaskTagFromISR);
  cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetApplicationTaskTagFromISR_CallInstance);
  Mock.xTaskGetApplicationTaskTagFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetApplicationTaskTagFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetApplicationTaskTagFromISR,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetApplicationTaskTagFromISR(CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask);
void CMockExpectParameters_xTaskGetApplicationTaskTagFromISR(CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void xTaskGetApplicationTaskTagFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHookFunction_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE));
  CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetApplicationTaskTagFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetApplicationTaskTagFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGetApplicationTaskTagFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskHookFunction_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE));
  CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetApplicationTaskTagFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetApplicationTaskTagFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGetApplicationTaskTagFromISR(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHookFunction_t[sizeof(cmock_to_return) == sizeof(TaskHookFunction_t) ? 1 : -1])); /* add TaskHookFunction_t to :treat_as_array if this causes an error */
}

void xTaskGetApplicationTaskTagFromISR_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetApplicationTaskTagFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet, BaseType_t xIndex, void* pvValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSetThreadLocalStoragePointer);
  cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSetThreadLocalStoragePointer_CallInstance);
  Mock.vTaskSetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemNext(Mock.vTaskSetThreadLocalStoragePointer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToSet)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetThreadLocalStoragePointer,CMockString_xTaskToSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToSet), (void*)(&xTaskToSet), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xIndex)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetThreadLocalStoragePointer,CMockString_xIndex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xIndex), (void*)(&xIndex), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvValue)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetThreadLocalStoragePointer,CMockString_pvValue);
    if (cmock_call_instance->Expected_pvValue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvValue, pvValue, 1, cmock_line, CMockStringMismatch); }
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pvValue_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvValue, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvValue, (const void*)cmock_call_instance->ReturnThruPtr_pvValue_Val,
      cmock_call_instance->ReturnThruPtr_pvValue_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSetThreadLocalStoragePointer(CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToSet, BaseType_t xIndex, void* pvValue);
void CMockExpectParameters_vTaskSetThreadLocalStoragePointer(CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToSet, BaseType_t xIndex, void* pvValue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToSet), (void*)(&xTaskToSet),
         sizeof(TaskHandle_t[sizeof(xTaskToSet) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToSet = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xIndex), (void*)(&xIndex),
         sizeof(BaseType_t[sizeof(xIndex) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xIndex = 0;
  cmock_call_instance->Expected_pvValue = pvValue;
  cmock_call_instance->IgnoreArg_pvValue = 0;
  cmock_call_instance->ReturnThruPtr_pvValue_Used = 0;
}

void vTaskSetThreadLocalStoragePointer_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE));
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetThreadLocalStoragePointer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskSetThreadLocalStoragePointer_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToSet, BaseType_t xIndex, void* pvValue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE));
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetThreadLocalStoragePointer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskSetThreadLocalStoragePointer(cmock_call_instance, xTaskToSet, xIndex, pvValue);
}

void vTaskSetThreadLocalStoragePointer_CMockReturnMemThruPtr_pvValue(UNITY_LINE_TYPE cmock_line, void const* pvValue, size_t cmock_size)
{
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetThreadLocalStoragePointer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvValue_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvValue_Val = pvValue;
  cmock_call_instance->ReturnThruPtr_pvValue_Size = cmock_size;
}

void vTaskSetThreadLocalStoragePointer_CMockIgnoreArg_xTaskToSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetThreadLocalStoragePointer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToSet = 1;
}

void vTaskSetThreadLocalStoragePointer_CMockIgnoreArg_xIndex(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetThreadLocalStoragePointer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xIndex = 1;
}

void vTaskSetThreadLocalStoragePointer_CMockIgnoreArg_pvValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetThreadLocalStoragePointer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvValue = 1;
}

void* pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pvTaskGetThreadLocalStoragePointer);
  cmock_call_instance = (CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance);
  Mock.pvTaskGetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemNext(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToQuery)
  {
    UNITY_SET_DETAILS(CMockString_pvTaskGetThreadLocalStoragePointer,CMockString_xTaskToQuery);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToQuery), (void*)(&xTaskToQuery), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xIndex)
  {
    UNITY_SET_DETAILS(CMockString_pvTaskGetThreadLocalStoragePointer,CMockString_xIndex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xIndex), (void*)(&xIndex), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pvTaskGetThreadLocalStoragePointer(CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToQuery, BaseType_t xIndex);
void CMockExpectParameters_pvTaskGetThreadLocalStoragePointer(CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToQuery), (void*)(&xTaskToQuery),
         sizeof(TaskHandle_t[sizeof(xTaskToQuery) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToQuery = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xIndex), (void*)(&xIndex),
         sizeof(BaseType_t[sizeof(xIndex) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xIndex = 0;
}

void pvTaskGetThreadLocalStoragePointer_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE));
  CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTaskGetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemChain(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void pvTaskGetThreadLocalStoragePointer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToQuery, BaseType_t xIndex, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE));
  CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTaskGetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemChain(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_pvTaskGetThreadLocalStoragePointer(cmock_call_instance, xTaskToQuery, xIndex);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pvTaskGetThreadLocalStoragePointer_CMockIgnoreArg_xTaskToQuery(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToQuery = 1;
}

void pvTaskGetThreadLocalStoragePointer_CMockIgnoreArg_xIndex(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xIndex = 1;
}

void vApplicationStackOverflowHook(TaskHandle_t xTask, char* pcTaskName)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vApplicationStackOverflowHook);
  cmock_call_instance = (CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vApplicationStackOverflowHook_CallInstance);
  Mock.vApplicationStackOverflowHook_CallInstance = CMock_Guts_MemNext(Mock.vApplicationStackOverflowHook_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationStackOverflowHook,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pcTaskName)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationStackOverflowHook,CMockString_pcTaskName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcTaskName, pcTaskName, cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pcTaskName_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pcTaskName, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pcTaskName, (const void*)cmock_call_instance->ReturnThruPtr_pcTaskName_Val,
      cmock_call_instance->ReturnThruPtr_pcTaskName_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vApplicationStackOverflowHook(CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, char* pcTaskName);
void CMockExpectParameters_vApplicationStackOverflowHook(CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, char* pcTaskName)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  cmock_call_instance->Expected_pcTaskName = pcTaskName;
  cmock_call_instance->IgnoreArg_pcTaskName = 0;
  cmock_call_instance->ReturnThruPtr_pcTaskName_Used = 0;
}

void vApplicationStackOverflowHook_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE));
  CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationStackOverflowHook_CallInstance = CMock_Guts_MemChain(Mock.vApplicationStackOverflowHook_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vApplicationStackOverflowHook_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, char* pcTaskName)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE));
  CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationStackOverflowHook_CallInstance = CMock_Guts_MemChain(Mock.vApplicationStackOverflowHook_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vApplicationStackOverflowHook(cmock_call_instance, xTask, pcTaskName);
}

void vApplicationStackOverflowHook_CMockReturnMemThruPtr_pcTaskName(UNITY_LINE_TYPE cmock_line, char const* pcTaskName, size_t cmock_size)
{
  CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationStackOverflowHook_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pcTaskName_Used = 1;
  cmock_call_instance->ReturnThruPtr_pcTaskName_Val = pcTaskName;
  cmock_call_instance->ReturnThruPtr_pcTaskName_Size = cmock_size;
}

void vApplicationStackOverflowHook_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationStackOverflowHook_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vApplicationStackOverflowHook_CMockIgnoreArg_pcTaskName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationStackOverflowHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationStackOverflowHook_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcTaskName = 1;
}

void vApplicationIdleHook(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vApplicationIdleHook_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vApplicationIdleHook);
  cmock_call_instance = (CMOCK_vApplicationIdleHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vApplicationIdleHook_CallInstance);
  Mock.vApplicationIdleHook_CallInstance = CMock_Guts_MemNext(Mock.vApplicationIdleHook_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vApplicationIdleHook_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationIdleHook_CALL_INSTANCE));
  CMOCK_vApplicationIdleHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationIdleHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationIdleHook_CallInstance = CMock_Guts_MemChain(Mock.vApplicationIdleHook_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vApplicationTickHook(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vApplicationTickHook_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vApplicationTickHook);
  cmock_call_instance = (CMOCK_vApplicationTickHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vApplicationTickHook_CallInstance);
  Mock.vApplicationTickHook_CallInstance = CMock_Guts_MemNext(Mock.vApplicationTickHook_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vApplicationTickHook_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationTickHook_CALL_INSTANCE));
  CMOCK_vApplicationTickHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationTickHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationTickHook_CallInstance = CMock_Guts_MemChain(Mock.vApplicationTickHook_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vApplicationGetIdleTaskMemory(StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE* puxIdleTaskStackSize)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vApplicationGetIdleTaskMemory);
  cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vApplicationGetIdleTaskMemory_CallInstance);
  Mock.vApplicationGetIdleTaskMemory_CallInstance = CMock_Guts_MemNext(Mock.vApplicationGetIdleTaskMemory_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ppxIdleTaskTCBBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetIdleTaskMemory,CMockString_ppxIdleTaskTCBBuffer);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxIdleTaskTCBBuffer, ppxIdleTaskTCBBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ppxIdleTaskStackBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetIdleTaskMemory,CMockString_ppxIdleTaskStackBuffer);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxIdleTaskStackBuffer, ppxIdleTaskStackBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_puxIdleTaskStackSize)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetIdleTaskMemory,CMockString_puxIdleTaskStackSize);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_puxIdleTaskStackSize), (void*)(puxIdleTaskStackSize), sizeof(configSTACK_DEPTH_TYPE), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxIdleTaskTCBBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxIdleTaskTCBBuffer, (const void*)cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Val,
      cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxIdleTaskStackBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxIdleTaskStackBuffer, (const void*)cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Val,
      cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(puxIdleTaskStackSize, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)puxIdleTaskStackSize, (const void*)cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Val,
      cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vApplicationGetIdleTaskMemory(CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance, StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE* puxIdleTaskStackSize);
void CMockExpectParameters_vApplicationGetIdleTaskMemory(CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance, StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE* puxIdleTaskStackSize)
{
  cmock_call_instance->Expected_ppxIdleTaskTCBBuffer = ppxIdleTaskTCBBuffer;
  cmock_call_instance->IgnoreArg_ppxIdleTaskTCBBuffer = 0;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Used = 0;
  cmock_call_instance->Expected_ppxIdleTaskStackBuffer = ppxIdleTaskStackBuffer;
  cmock_call_instance->IgnoreArg_ppxIdleTaskStackBuffer = 0;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Used = 0;
  cmock_call_instance->Expected_puxIdleTaskStackSize = puxIdleTaskStackSize;
  cmock_call_instance->IgnoreArg_puxIdleTaskStackSize = 0;
  cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Used = 0;
}

void vApplicationGetIdleTaskMemory_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE));
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationGetIdleTaskMemory_CallInstance = CMock_Guts_MemChain(Mock.vApplicationGetIdleTaskMemory_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vApplicationGetIdleTaskMemory_CMockExpect(UNITY_LINE_TYPE cmock_line, StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE* puxIdleTaskStackSize)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE));
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationGetIdleTaskMemory_CallInstance = CMock_Guts_MemChain(Mock.vApplicationGetIdleTaskMemory_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vApplicationGetIdleTaskMemory(cmock_call_instance, ppxIdleTaskTCBBuffer, ppxIdleTaskStackBuffer, puxIdleTaskStackSize);
}

void vApplicationGetIdleTaskMemory_CMockReturnMemThruPtr_ppxIdleTaskTCBBuffer(UNITY_LINE_TYPE cmock_line, StaticTask_t* const* ppxIdleTaskTCBBuffer, size_t cmock_size)
{
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Val = ppxIdleTaskTCBBuffer;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Size = cmock_size;
}

void vApplicationGetIdleTaskMemory_CMockReturnMemThruPtr_ppxIdleTaskStackBuffer(UNITY_LINE_TYPE cmock_line, StackType_t* const* ppxIdleTaskStackBuffer, size_t cmock_size)
{
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Val = ppxIdleTaskStackBuffer;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Size = cmock_size;
}

void vApplicationGetIdleTaskMemory_CMockReturnMemThruPtr_puxIdleTaskStackSize(UNITY_LINE_TYPE cmock_line, configSTACK_DEPTH_TYPE const* puxIdleTaskStackSize, size_t cmock_size)
{
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Used = 1;
  cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Val = puxIdleTaskStackSize;
  cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Size = cmock_size;
}

void vApplicationGetIdleTaskMemory_CMockIgnoreArg_ppxIdleTaskTCBBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxIdleTaskTCBBuffer = 1;
}

void vApplicationGetIdleTaskMemory_CMockIgnoreArg_ppxIdleTaskStackBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxIdleTaskStackBuffer = 1;
}

void vApplicationGetIdleTaskMemory_CMockIgnoreArg_puxIdleTaskStackSize(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_puxIdleTaskStackSize = 1;
}

void vApplicationGetPassiveIdleTaskMemory(StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE* puxIdleTaskStackSize, BaseType_t xPassiveIdleTaskIndex)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vApplicationGetPassiveIdleTaskMemory);
  cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance);
  Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance = CMock_Guts_MemNext(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ppxIdleTaskTCBBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetPassiveIdleTaskMemory,CMockString_ppxIdleTaskTCBBuffer);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxIdleTaskTCBBuffer, ppxIdleTaskTCBBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ppxIdleTaskStackBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetPassiveIdleTaskMemory,CMockString_ppxIdleTaskStackBuffer);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxIdleTaskStackBuffer, ppxIdleTaskStackBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_puxIdleTaskStackSize)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetPassiveIdleTaskMemory,CMockString_puxIdleTaskStackSize);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_puxIdleTaskStackSize), (void*)(puxIdleTaskStackSize), sizeof(configSTACK_DEPTH_TYPE), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xPassiveIdleTaskIndex)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetPassiveIdleTaskMemory,CMockString_xPassiveIdleTaskIndex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xPassiveIdleTaskIndex), (void*)(&xPassiveIdleTaskIndex), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxIdleTaskTCBBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxIdleTaskTCBBuffer, (const void*)cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Val,
      cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxIdleTaskStackBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxIdleTaskStackBuffer, (const void*)cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Val,
      cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(puxIdleTaskStackSize, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)puxIdleTaskStackSize, (const void*)cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Val,
      cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vApplicationGetPassiveIdleTaskMemory(CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance, StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE* puxIdleTaskStackSize, BaseType_t xPassiveIdleTaskIndex);
void CMockExpectParameters_vApplicationGetPassiveIdleTaskMemory(CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance, StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE* puxIdleTaskStackSize, BaseType_t xPassiveIdleTaskIndex)
{
  cmock_call_instance->Expected_ppxIdleTaskTCBBuffer = ppxIdleTaskTCBBuffer;
  cmock_call_instance->IgnoreArg_ppxIdleTaskTCBBuffer = 0;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Used = 0;
  cmock_call_instance->Expected_ppxIdleTaskStackBuffer = ppxIdleTaskStackBuffer;
  cmock_call_instance->IgnoreArg_ppxIdleTaskStackBuffer = 0;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Used = 0;
  cmock_call_instance->Expected_puxIdleTaskStackSize = puxIdleTaskStackSize;
  cmock_call_instance->IgnoreArg_puxIdleTaskStackSize = 0;
  cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xPassiveIdleTaskIndex), (void*)(&xPassiveIdleTaskIndex),
         sizeof(BaseType_t[sizeof(xPassiveIdleTaskIndex) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xPassiveIdleTaskIndex = 0;
}

void vApplicationGetPassiveIdleTaskMemory_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE));
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance = CMock_Guts_MemChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vApplicationGetPassiveIdleTaskMemory_CMockExpect(UNITY_LINE_TYPE cmock_line, StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, configSTACK_DEPTH_TYPE* puxIdleTaskStackSize, BaseType_t xPassiveIdleTaskIndex)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE));
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance = CMock_Guts_MemChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vApplicationGetPassiveIdleTaskMemory(cmock_call_instance, ppxIdleTaskTCBBuffer, ppxIdleTaskStackBuffer, puxIdleTaskStackSize, xPassiveIdleTaskIndex);
}

void vApplicationGetPassiveIdleTaskMemory_CMockReturnMemThruPtr_ppxIdleTaskTCBBuffer(UNITY_LINE_TYPE cmock_line, StaticTask_t* const* ppxIdleTaskTCBBuffer, size_t cmock_size)
{
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Val = ppxIdleTaskTCBBuffer;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskTCBBuffer_Size = cmock_size;
}

void vApplicationGetPassiveIdleTaskMemory_CMockReturnMemThruPtr_ppxIdleTaskStackBuffer(UNITY_LINE_TYPE cmock_line, StackType_t* const* ppxIdleTaskStackBuffer, size_t cmock_size)
{
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Val = ppxIdleTaskStackBuffer;
  cmock_call_instance->ReturnThruPtr_ppxIdleTaskStackBuffer_Size = cmock_size;
}

void vApplicationGetPassiveIdleTaskMemory_CMockReturnMemThruPtr_puxIdleTaskStackSize(UNITY_LINE_TYPE cmock_line, configSTACK_DEPTH_TYPE const* puxIdleTaskStackSize, size_t cmock_size)
{
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Used = 1;
  cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Val = puxIdleTaskStackSize;
  cmock_call_instance->ReturnThruPtr_puxIdleTaskStackSize_Size = cmock_size;
}

void vApplicationGetPassiveIdleTaskMemory_CMockIgnoreArg_ppxIdleTaskTCBBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxIdleTaskTCBBuffer = 1;
}

void vApplicationGetPassiveIdleTaskMemory_CMockIgnoreArg_ppxIdleTaskStackBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxIdleTaskStackBuffer = 1;
}

void vApplicationGetPassiveIdleTaskMemory_CMockIgnoreArg_puxIdleTaskStackSize(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_puxIdleTaskStackSize = 1;
}

void vApplicationGetPassiveIdleTaskMemory_CMockIgnoreArg_xPassiveIdleTaskIndex(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetPassiveIdleTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetPassiveIdleTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xPassiveIdleTaskIndex = 1;
}

BaseType_t xTaskCallApplicationTaskHook(TaskHandle_t xTask, void* pvParameter)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCallApplicationTaskHook);
  cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCallApplicationTaskHook_CallInstance);
  Mock.xTaskCallApplicationTaskHook_CallInstance = CMock_Guts_MemNext(Mock.xTaskCallApplicationTaskHook_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCallApplicationTaskHook,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameter)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCallApplicationTaskHook,CMockString_pvParameter);
    if (cmock_call_instance->Expected_pvParameter == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameter, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameter, pvParameter, 1, cmock_line, CMockStringMismatch); }
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pvParameter_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvParameter, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvParameter, (const void*)cmock_call_instance->ReturnThruPtr_pvParameter_Val,
      cmock_call_instance->ReturnThruPtr_pvParameter_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCallApplicationTaskHook(CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, void* pvParameter);
void CMockExpectParameters_xTaskCallApplicationTaskHook(CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, void* pvParameter)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  cmock_call_instance->Expected_pvParameter = pvParameter;
  cmock_call_instance->IgnoreArg_pvParameter = 0;
  cmock_call_instance->ReturnThruPtr_pvParameter_Used = 0;
}

void xTaskCallApplicationTaskHook_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE));
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCallApplicationTaskHook_CallInstance = CMock_Guts_MemChain(Mock.xTaskCallApplicationTaskHook_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCallApplicationTaskHook_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, void* pvParameter, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE));
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCallApplicationTaskHook_CallInstance = CMock_Guts_MemChain(Mock.xTaskCallApplicationTaskHook_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCallApplicationTaskHook(cmock_call_instance, xTask, pvParameter);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCallApplicationTaskHook_CMockReturnMemThruPtr_pvParameter(UNITY_LINE_TYPE cmock_line, void const* pvParameter, size_t cmock_size)
{
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCallApplicationTaskHook_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvParameter_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvParameter_Val = pvParameter;
  cmock_call_instance->ReturnThruPtr_pvParameter_Size = cmock_size;
}

void xTaskCallApplicationTaskHook_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCallApplicationTaskHook_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void xTaskCallApplicationTaskHook_CMockIgnoreArg_pvParameter(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCallApplicationTaskHook_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameter = 1;
}

TaskHandle_t xTaskGetIdleTaskHandle(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetIdleTaskHandle);
  cmock_call_instance = (CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetIdleTaskHandle_CallInstance);
  Mock.xTaskGetIdleTaskHandle_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetIdleTaskHandle_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetIdleTaskHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE));
  CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetIdleTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetIdleTaskHandle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

TaskHandle_t xTaskGetIdleTaskHandleForCore(BaseType_t xCoreID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetIdleTaskHandleForCore);
  cmock_call_instance = (CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetIdleTaskHandleForCore_CallInstance);
  Mock.xTaskGetIdleTaskHandleForCore_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetIdleTaskHandleForCore_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xCoreID)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetIdleTaskHandleForCore,CMockString_xCoreID);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCoreID), (void*)(&xCoreID), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetIdleTaskHandleForCore(CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE* cmock_call_instance, BaseType_t xCoreID);
void CMockExpectParameters_xTaskGetIdleTaskHandleForCore(CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE* cmock_call_instance, BaseType_t xCoreID)
{
  memcpy((void*)(&cmock_call_instance->Expected_xCoreID), (void*)(&xCoreID),
         sizeof(BaseType_t[sizeof(xCoreID) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xCoreID = 0;
}

void xTaskGetIdleTaskHandleForCore_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE));
  CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetIdleTaskHandleForCore_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetIdleTaskHandleForCore_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGetIdleTaskHandleForCore_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t xCoreID, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE));
  CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetIdleTaskHandleForCore_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetIdleTaskHandleForCore_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGetIdleTaskHandleForCore(cmock_call_instance, xCoreID);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskGetIdleTaskHandleForCore_CMockIgnoreArg_xCoreID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetIdleTaskHandleForCore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetIdleTaskHandleForCore_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xCoreID = 1;
}

UBaseType_t uxTaskGetSystemState(TaskStatus_t* const pxTaskStatusArray, const UBaseType_t uxArraySize, configRUN_TIME_COUNTER_TYPE* const pulTotalRunTime)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetSystemState);
  cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetSystemState_CallInstance);
  Mock.uxTaskGetSystemState_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetSystemState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskStatusArray)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetSystemState,CMockString_pxTaskStatusArray);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskStatusArray), (void*)(pxTaskStatusArray), sizeof(TaskStatus_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxArraySize)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetSystemState,CMockString_uxArraySize);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxArraySize), (void*)(&uxArraySize), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pulTotalRunTime)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetSystemState,CMockString_pulTotalRunTime);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pulTotalRunTime), (void*)(pulTotalRunTime), sizeof(configRUN_TIME_COUNTER_TYPE), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxTaskStatusArray_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTaskStatusArray, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTaskStatusArray, (const void*)cmock_call_instance->ReturnThruPtr_pxTaskStatusArray_Val,
      cmock_call_instance->ReturnThruPtr_pxTaskStatusArray_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pulTotalRunTime_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pulTotalRunTime, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pulTotalRunTime, (const void*)cmock_call_instance->ReturnThruPtr_pulTotalRunTime_Val,
      cmock_call_instance->ReturnThruPtr_pulTotalRunTime_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskGetSystemState(CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance, TaskStatus_t* const pxTaskStatusArray, const UBaseType_t uxArraySize, configRUN_TIME_COUNTER_TYPE* const pulTotalRunTime);
void CMockExpectParameters_uxTaskGetSystemState(CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance, TaskStatus_t* const pxTaskStatusArray, const UBaseType_t uxArraySize, configRUN_TIME_COUNTER_TYPE* const pulTotalRunTime)
{
  cmock_call_instance->Expected_pxTaskStatusArray = pxTaskStatusArray;
  cmock_call_instance->IgnoreArg_pxTaskStatusArray = 0;
  cmock_call_instance->ReturnThruPtr_pxTaskStatusArray_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxArraySize), (void*)(&uxArraySize),
         sizeof(UBaseType_t[sizeof(uxArraySize) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxArraySize = 0;
  cmock_call_instance->Expected_pulTotalRunTime = pulTotalRunTime;
  cmock_call_instance->IgnoreArg_pulTotalRunTime = 0;
  cmock_call_instance->ReturnThruPtr_pulTotalRunTime_Used = 0;
}

void uxTaskGetSystemState_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetSystemState_CALL_INSTANCE));
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetSystemState_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetSystemState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTaskGetSystemState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskStatus_t* const pxTaskStatusArray, const UBaseType_t uxArraySize, configRUN_TIME_COUNTER_TYPE* const pulTotalRunTime, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetSystemState_CALL_INSTANCE));
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetSystemState_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetSystemState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTaskGetSystemState(cmock_call_instance, pxTaskStatusArray, uxArraySize, pulTotalRunTime);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTaskGetSystemState_CMockReturnMemThruPtr_pxTaskStatusArray(UNITY_LINE_TYPE cmock_line, TaskStatus_t const* pxTaskStatusArray, size_t cmock_size)
{
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskGetSystemState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTaskStatusArray_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTaskStatusArray_Val = pxTaskStatusArray;
  cmock_call_instance->ReturnThruPtr_pxTaskStatusArray_Size = cmock_size;
}

void uxTaskGetSystemState_CMockReturnMemThruPtr_pulTotalRunTime(UNITY_LINE_TYPE cmock_line, configRUN_TIME_COUNTER_TYPE const* pulTotalRunTime, size_t cmock_size)
{
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskGetSystemState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pulTotalRunTime_Used = 1;
  cmock_call_instance->ReturnThruPtr_pulTotalRunTime_Val = pulTotalRunTime;
  cmock_call_instance->ReturnThruPtr_pulTotalRunTime_Size = cmock_size;
}

void uxTaskGetSystemState_CMockIgnoreArg_pxTaskStatusArray(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskGetSystemState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskStatusArray = 1;
}

void uxTaskGetSystemState_CMockIgnoreArg_uxArraySize(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskGetSystemState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxArraySize = 1;
}

void uxTaskGetSystemState_CMockIgnoreArg_pulTotalRunTime(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskGetSystemState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pulTotalRunTime = 1;
}

void vTaskListTasks(char* pcWriteBuffer, size_t uxBufferLength)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskListTasks_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskListTasks);
  cmock_call_instance = (CMOCK_vTaskListTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskListTasks_CallInstance);
  Mock.vTaskListTasks_CallInstance = CMock_Guts_MemNext(Mock.vTaskListTasks_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pcWriteBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vTaskListTasks,CMockString_pcWriteBuffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcWriteBuffer, pcWriteBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBufferLength)
  {
    UNITY_SET_DETAILS(CMockString_vTaskListTasks,CMockString_uxBufferLength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBufferLength), (void*)(&uxBufferLength), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pcWriteBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pcWriteBuffer, (const void*)cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskListTasks(CMOCK_vTaskListTasks_CALL_INSTANCE* cmock_call_instance, char* pcWriteBuffer, size_t uxBufferLength);
void CMockExpectParameters_vTaskListTasks(CMOCK_vTaskListTasks_CALL_INSTANCE* cmock_call_instance, char* pcWriteBuffer, size_t uxBufferLength)
{
  cmock_call_instance->Expected_pcWriteBuffer = pcWriteBuffer;
  cmock_call_instance->IgnoreArg_pcWriteBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBufferLength), (void*)(&uxBufferLength),
         sizeof(size_t[sizeof(uxBufferLength) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBufferLength = 0;
}

void vTaskListTasks_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskListTasks_CALL_INSTANCE));
  CMOCK_vTaskListTasks_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskListTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskListTasks_CallInstance = CMock_Guts_MemChain(Mock.vTaskListTasks_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskListTasks_CMockExpect(UNITY_LINE_TYPE cmock_line, char* pcWriteBuffer, size_t uxBufferLength)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskListTasks_CALL_INSTANCE));
  CMOCK_vTaskListTasks_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskListTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskListTasks_CallInstance = CMock_Guts_MemChain(Mock.vTaskListTasks_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskListTasks(cmock_call_instance, pcWriteBuffer, uxBufferLength);
}

void vTaskListTasks_CMockReturnMemThruPtr_pcWriteBuffer(UNITY_LINE_TYPE cmock_line, char const* pcWriteBuffer, size_t cmock_size)
{
  CMOCK_vTaskListTasks_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskListTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskListTasks_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Val = pcWriteBuffer;
  cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Size = cmock_size;
}

void vTaskListTasks_CMockIgnoreArg_pcWriteBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskListTasks_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskListTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskListTasks_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcWriteBuffer = 1;
}

void vTaskListTasks_CMockIgnoreArg_uxBufferLength(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskListTasks_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskListTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskListTasks_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBufferLength = 1;
}

void vTaskGetRunTimeStatistics(char* pcWriteBuffer, size_t uxBufferLength)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskGetRunTimeStatistics);
  cmock_call_instance = (CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskGetRunTimeStatistics_CallInstance);
  Mock.vTaskGetRunTimeStatistics_CallInstance = CMock_Guts_MemNext(Mock.vTaskGetRunTimeStatistics_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pcWriteBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetRunTimeStatistics,CMockString_pcWriteBuffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcWriteBuffer, pcWriteBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBufferLength)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetRunTimeStatistics,CMockString_uxBufferLength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBufferLength), (void*)(&uxBufferLength), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pcWriteBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pcWriteBuffer, (const void*)cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskGetRunTimeStatistics(CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE* cmock_call_instance, char* pcWriteBuffer, size_t uxBufferLength);
void CMockExpectParameters_vTaskGetRunTimeStatistics(CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE* cmock_call_instance, char* pcWriteBuffer, size_t uxBufferLength)
{
  cmock_call_instance->Expected_pcWriteBuffer = pcWriteBuffer;
  cmock_call_instance->IgnoreArg_pcWriteBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBufferLength), (void*)(&uxBufferLength),
         sizeof(size_t[sizeof(uxBufferLength) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBufferLength = 0;
}

void vTaskGetRunTimeStatistics_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE));
  CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGetRunTimeStatistics_CallInstance = CMock_Guts_MemChain(Mock.vTaskGetRunTimeStatistics_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskGetRunTimeStatistics_CMockExpect(UNITY_LINE_TYPE cmock_line, char* pcWriteBuffer, size_t uxBufferLength)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE));
  CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGetRunTimeStatistics_CallInstance = CMock_Guts_MemChain(Mock.vTaskGetRunTimeStatistics_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskGetRunTimeStatistics(cmock_call_instance, pcWriteBuffer, uxBufferLength);
}

void vTaskGetRunTimeStatistics_CMockReturnMemThruPtr_pcWriteBuffer(UNITY_LINE_TYPE cmock_line, char const* pcWriteBuffer, size_t cmock_size)
{
  CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGetRunTimeStatistics_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Val = pcWriteBuffer;
  cmock_call_instance->ReturnThruPtr_pcWriteBuffer_Size = cmock_size;
}

void vTaskGetRunTimeStatistics_CMockIgnoreArg_pcWriteBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGetRunTimeStatistics_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcWriteBuffer = 1;
}

void vTaskGetRunTimeStatistics_CMockIgnoreArg_uxBufferLength(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetRunTimeStatistics_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGetRunTimeStatistics_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBufferLength = 1;
}

configRUN_TIME_COUNTER_TYPE ulTaskGetRunTimeCounter(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulTaskGetRunTimeCounter);
  cmock_call_instance = (CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulTaskGetRunTimeCounter_CallInstance);
  Mock.ulTaskGetRunTimeCounter_CallInstance = CMock_Guts_MemNext(Mock.ulTaskGetRunTimeCounter_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_ulTaskGetRunTimeCounter,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ulTaskGetRunTimeCounter(CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask);
void CMockExpectParameters_ulTaskGetRunTimeCounter(CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void ulTaskGetRunTimeCounter_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, configRUN_TIME_COUNTER_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE));
  CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGetRunTimeCounter_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGetRunTimeCounter_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void ulTaskGetRunTimeCounter_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, configRUN_TIME_COUNTER_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE));
  CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGetRunTimeCounter_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGetRunTimeCounter_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_ulTaskGetRunTimeCounter(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(configRUN_TIME_COUNTER_TYPE[sizeof(cmock_to_return) == sizeof(configRUN_TIME_COUNTER_TYPE) ? 1 : -1])); /* add configRUN_TIME_COUNTER_TYPE to :treat_as_array if this causes an error */
}

void ulTaskGetRunTimeCounter_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGetRunTimeCounter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulTaskGetRunTimeCounter_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

configRUN_TIME_COUNTER_TYPE ulTaskGetRunTimePercent(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulTaskGetRunTimePercent);
  cmock_call_instance = (CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulTaskGetRunTimePercent_CallInstance);
  Mock.ulTaskGetRunTimePercent_CallInstance = CMock_Guts_MemNext(Mock.ulTaskGetRunTimePercent_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_ulTaskGetRunTimePercent,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ulTaskGetRunTimePercent(CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask);
void CMockExpectParameters_ulTaskGetRunTimePercent(CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void ulTaskGetRunTimePercent_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, configRUN_TIME_COUNTER_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE));
  CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGetRunTimePercent_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGetRunTimePercent_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void ulTaskGetRunTimePercent_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, configRUN_TIME_COUNTER_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE));
  CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGetRunTimePercent_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGetRunTimePercent_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_ulTaskGetRunTimePercent(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(configRUN_TIME_COUNTER_TYPE[sizeof(cmock_to_return) == sizeof(configRUN_TIME_COUNTER_TYPE) ? 1 : -1])); /* add configRUN_TIME_COUNTER_TYPE to :treat_as_array if this causes an error */
}

void ulTaskGetRunTimePercent_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGetRunTimePercent_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulTaskGetRunTimePercent_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulTaskGetIdleRunTimeCounter_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulTaskGetIdleRunTimeCounter);
  cmock_call_instance = (CMOCK_ulTaskGetIdleRunTimeCounter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulTaskGetIdleRunTimeCounter_CallInstance);
  Mock.ulTaskGetIdleRunTimeCounter_CallInstance = CMock_Guts_MemNext(Mock.ulTaskGetIdleRunTimeCounter_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void ulTaskGetIdleRunTimeCounter_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, configRUN_TIME_COUNTER_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGetIdleRunTimeCounter_CALL_INSTANCE));
  CMOCK_ulTaskGetIdleRunTimeCounter_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGetIdleRunTimeCounter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGetIdleRunTimeCounter_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGetIdleRunTimeCounter_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(configRUN_TIME_COUNTER_TYPE[sizeof(cmock_to_return) == sizeof(configRUN_TIME_COUNTER_TYPE) ? 1 : -1])); /* add configRUN_TIME_COUNTER_TYPE to :treat_as_array if this causes an error */
}

configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulTaskGetIdleRunTimePercent_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulTaskGetIdleRunTimePercent);
  cmock_call_instance = (CMOCK_ulTaskGetIdleRunTimePercent_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulTaskGetIdleRunTimePercent_CallInstance);
  Mock.ulTaskGetIdleRunTimePercent_CallInstance = CMock_Guts_MemNext(Mock.ulTaskGetIdleRunTimePercent_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void ulTaskGetIdleRunTimePercent_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, configRUN_TIME_COUNTER_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGetIdleRunTimePercent_CALL_INSTANCE));
  CMOCK_ulTaskGetIdleRunTimePercent_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGetIdleRunTimePercent_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGetIdleRunTimePercent_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGetIdleRunTimePercent_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(configRUN_TIME_COUNTER_TYPE[sizeof(cmock_to_return) == sizeof(configRUN_TIME_COUNTER_TYPE) ? 1 : -1])); /* add configRUN_TIME_COUNTER_TYPE to :treat_as_array if this causes an error */
}

BaseType_t xTaskGenericNotify(TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGenericNotify);
  cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGenericNotify_CallInstance);
  Mock.xTaskGenericNotify_CallInstance = CMock_Guts_MemNext(Mock.xTaskGenericNotify_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToNotify)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_xTaskToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxIndexToNotify)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_uxIndexToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxIndexToNotify), (void*)(&uxIndexToNotify), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ulValue)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_ulValue);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulValue, ulValue, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_eAction)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_eAction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eAction), (void*)(&eAction), sizeof(eNotifyAction), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pulPreviousNotificationValue)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_pulPreviousNotificationValue);
    if (cmock_call_instance->Expected_pulPreviousNotificationValue == NULL)
      { UNITY_TEST_ASSERT_NULL(pulPreviousNotificationValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulPreviousNotificationValue, pulPreviousNotificationValue, 1, cmock_line, CMockStringMismatch); }
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pulPreviousNotificationValue, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pulPreviousNotificationValue, (const void*)cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Val,
      cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGenericNotify(CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue);
void CMockExpectParameters_xTaskGenericNotify(CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify),
         sizeof(TaskHandle_t[sizeof(xTaskToNotify) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToNotify = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxIndexToNotify), (void*)(&uxIndexToNotify),
         sizeof(UBaseType_t[sizeof(uxIndexToNotify) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxIndexToNotify = 0;
  cmock_call_instance->Expected_ulValue = ulValue;
  cmock_call_instance->IgnoreArg_ulValue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_eAction), (void*)(&eAction),
         sizeof(eNotifyAction[sizeof(eAction) == sizeof(eNotifyAction) ? 1 : -1])); /* add eNotifyAction to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eAction = 0;
  cmock_call_instance->Expected_pulPreviousNotificationValue = pulPreviousNotificationValue;
  cmock_call_instance->IgnoreArg_pulPreviousNotificationValue = 0;
  cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Used = 0;
}

void xTaskGenericNotify_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotify_CALL_INSTANCE));
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotify_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotify_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGenericNotify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotify_CALL_INSTANCE));
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotify_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotify_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGenericNotify(cmock_call_instance, xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskGenericNotify_CMockReturnMemThruPtr_pulPreviousNotificationValue(UNITY_LINE_TYPE cmock_line, uint32_t const* pulPreviousNotificationValue, size_t cmock_size)
{
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotify_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Used = 1;
  cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Val = pulPreviousNotificationValue;
  cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Size = cmock_size;
}

void xTaskGenericNotify_CMockIgnoreArg_xTaskToNotify(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotify_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToNotify = 1;
}

void xTaskGenericNotify_CMockIgnoreArg_uxIndexToNotify(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotify_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxIndexToNotify = 1;
}

void xTaskGenericNotify_CMockIgnoreArg_ulValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotify_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulValue = 1;
}

void xTaskGenericNotify_CMockIgnoreArg_eAction(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotify_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eAction = 1;
}

void xTaskGenericNotify_CMockIgnoreArg_pulPreviousNotificationValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotify_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pulPreviousNotificationValue = 1;
}

BaseType_t xTaskGenericNotifyFromISR(TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGenericNotifyFromISR);
  cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGenericNotifyFromISR_CallInstance);
  Mock.xTaskGenericNotifyFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskGenericNotifyFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToNotify)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_xTaskToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxIndexToNotify)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_uxIndexToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxIndexToNotify), (void*)(&uxIndexToNotify), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ulValue)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_ulValue);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulValue, ulValue, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_eAction)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_eAction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eAction), (void*)(&eAction), sizeof(eNotifyAction), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pulPreviousNotificationValue)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_pulPreviousNotificationValue);
    if (cmock_call_instance->Expected_pulPreviousNotificationValue == NULL)
      { UNITY_TEST_ASSERT_NULL(pulPreviousNotificationValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulPreviousNotificationValue, pulPreviousNotificationValue, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pulPreviousNotificationValue, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pulPreviousNotificationValue, (const void*)cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Val,
      cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxHigherPriorityTaskWoken, (const void*)cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGenericNotifyFromISR(CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, BaseType_t* pxHigherPriorityTaskWoken);
void CMockExpectParameters_xTaskGenericNotifyFromISR(CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, BaseType_t* pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify),
         sizeof(TaskHandle_t[sizeof(xTaskToNotify) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToNotify = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxIndexToNotify), (void*)(&uxIndexToNotify),
         sizeof(UBaseType_t[sizeof(uxIndexToNotify) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxIndexToNotify = 0;
  cmock_call_instance->Expected_ulValue = ulValue;
  cmock_call_instance->IgnoreArg_ulValue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_eAction), (void*)(&eAction),
         sizeof(eNotifyAction[sizeof(eAction) == sizeof(eNotifyAction) ? 1 : -1])); /* add eNotifyAction to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eAction = 0;
  cmock_call_instance->Expected_pulPreviousNotificationValue = pulPreviousNotificationValue;
  cmock_call_instance->IgnoreArg_pulPreviousNotificationValue = 0;
  cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Used = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 0;
}

void xTaskGenericNotifyFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE));
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotifyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotifyFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGenericNotifyFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE));
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotifyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotifyFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGenericNotifyFromISR(cmock_call_instance, xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskGenericNotifyFromISR_CMockReturnMemThruPtr_pulPreviousNotificationValue(UNITY_LINE_TYPE cmock_line, uint32_t const* pulPreviousNotificationValue, size_t cmock_size)
{
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Used = 1;
  cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Val = pulPreviousNotificationValue;
  cmock_call_instance->ReturnThruPtr_pulPreviousNotificationValue_Size = cmock_size;
}

void xTaskGenericNotifyFromISR_CMockReturnMemThruPtr_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t const* pxHigherPriorityTaskWoken, size_t cmock_size)
{
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val = pxHigherPriorityTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size = cmock_size;
}

void xTaskGenericNotifyFromISR_CMockIgnoreArg_xTaskToNotify(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToNotify = 1;
}

void xTaskGenericNotifyFromISR_CMockIgnoreArg_uxIndexToNotify(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxIndexToNotify = 1;
}

void xTaskGenericNotifyFromISR_CMockIgnoreArg_ulValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulValue = 1;
}

void xTaskGenericNotifyFromISR_CMockIgnoreArg_eAction(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eAction = 1;
}

void xTaskGenericNotifyFromISR_CMockIgnoreArg_pulPreviousNotificationValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pulPreviousNotificationValue = 1;
}

void xTaskGenericNotifyFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

BaseType_t xTaskGenericNotifyWait(UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t* pulNotificationValue, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGenericNotifyWait);
  cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGenericNotifyWait_CallInstance);
  Mock.xTaskGenericNotifyWait_CallInstance = CMock_Guts_MemNext(Mock.xTaskGenericNotifyWait_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uxIndexToWaitOn)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyWait,CMockString_uxIndexToWaitOn);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxIndexToWaitOn), (void*)(&uxIndexToWaitOn), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ulBitsToClearOnEntry)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyWait,CMockString_ulBitsToClearOnEntry);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToClearOnEntry, ulBitsToClearOnEntry, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ulBitsToClearOnExit)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyWait,CMockString_ulBitsToClearOnExit);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToClearOnExit, ulBitsToClearOnExit, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pulNotificationValue)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyWait,CMockString_pulNotificationValue);
    if (cmock_call_instance->Expected_pulNotificationValue == NULL)
      { UNITY_TEST_ASSERT_NULL(pulNotificationValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulNotificationValue, pulNotificationValue, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyWait,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pulNotificationValue_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pulNotificationValue, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pulNotificationValue, (const void*)cmock_call_instance->ReturnThruPtr_pulNotificationValue_Val,
      cmock_call_instance->ReturnThruPtr_pulNotificationValue_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGenericNotifyWait(CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance, UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t* pulNotificationValue, TickType_t xTicksToWait);
void CMockExpectParameters_xTaskGenericNotifyWait(CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance, UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t* pulNotificationValue, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxIndexToWaitOn), (void*)(&uxIndexToWaitOn),
         sizeof(UBaseType_t[sizeof(uxIndexToWaitOn) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxIndexToWaitOn = 0;
  cmock_call_instance->Expected_ulBitsToClearOnEntry = ulBitsToClearOnEntry;
  cmock_call_instance->IgnoreArg_ulBitsToClearOnEntry = 0;
  cmock_call_instance->Expected_ulBitsToClearOnExit = ulBitsToClearOnExit;
  cmock_call_instance->IgnoreArg_ulBitsToClearOnExit = 0;
  cmock_call_instance->Expected_pulNotificationValue = pulNotificationValue;
  cmock_call_instance->IgnoreArg_pulNotificationValue = 0;
  cmock_call_instance->ReturnThruPtr_pulNotificationValue_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xTaskGenericNotifyWait_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE));
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotifyWait_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotifyWait_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGenericNotifyWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t* pulNotificationValue, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE));
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotifyWait_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotifyWait_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGenericNotifyWait(cmock_call_instance, uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskGenericNotifyWait_CMockReturnMemThruPtr_pulNotificationValue(UNITY_LINE_TYPE cmock_line, uint32_t const* pulNotificationValue, size_t cmock_size)
{
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyWait_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pulNotificationValue_Used = 1;
  cmock_call_instance->ReturnThruPtr_pulNotificationValue_Val = pulNotificationValue;
  cmock_call_instance->ReturnThruPtr_pulNotificationValue_Size = cmock_size;
}

void xTaskGenericNotifyWait_CMockIgnoreArg_uxIndexToWaitOn(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyWait_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxIndexToWaitOn = 1;
}

void xTaskGenericNotifyWait_CMockIgnoreArg_ulBitsToClearOnEntry(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyWait_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulBitsToClearOnEntry = 1;
}

void xTaskGenericNotifyWait_CMockIgnoreArg_ulBitsToClearOnExit(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyWait_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulBitsToClearOnExit = 1;
}

void xTaskGenericNotifyWait_CMockIgnoreArg_pulNotificationValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyWait_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pulNotificationValue = 1;
}

void xTaskGenericNotifyWait_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyWait_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

void vTaskGenericNotifyGiveFromISR(TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskGenericNotifyGiveFromISR);
  cmock_call_instance = (CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskGenericNotifyGiveFromISR_CallInstance);
  Mock.vTaskGenericNotifyGiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.vTaskGenericNotifyGiveFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTaskToNotify)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGenericNotifyGiveFromISR,CMockString_xTaskToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxIndexToNotify)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGenericNotifyGiveFromISR,CMockString_uxIndexToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxIndexToNotify), (void*)(&uxIndexToNotify), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_vTaskGenericNotifyGiveFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxHigherPriorityTaskWoken, (const void*)cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskGenericNotifyGiveFromISR(CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, BaseType_t* pxHigherPriorityTaskWoken);
void CMockExpectParameters_vTaskGenericNotifyGiveFromISR(CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, BaseType_t* pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify),
         sizeof(TaskHandle_t[sizeof(xTaskToNotify) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTaskToNotify = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxIndexToNotify), (void*)(&uxIndexToNotify),
         sizeof(UBaseType_t[sizeof(uxIndexToNotify) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxIndexToNotify = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 0;
}

void vTaskGenericNotifyGiveFromISR_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE));
  CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGenericNotifyGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.vTaskGenericNotifyGiveFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskGenericNotifyGiveFromISR_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, BaseType_t* pxHigherPriorityTaskWoken)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE));
  CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGenericNotifyGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.vTaskGenericNotifyGiveFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskGenericNotifyGiveFromISR(cmock_call_instance, xTaskToNotify, uxIndexToNotify, pxHigherPriorityTaskWoken);
}

void vTaskGenericNotifyGiveFromISR_CMockReturnMemThruPtr_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t const* pxHigherPriorityTaskWoken, size_t cmock_size)
{
  CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGenericNotifyGiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val = pxHigherPriorityTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size = cmock_size;
}

void vTaskGenericNotifyGiveFromISR_CMockIgnoreArg_xTaskToNotify(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGenericNotifyGiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTaskToNotify = 1;
}

void vTaskGenericNotifyGiveFromISR_CMockIgnoreArg_uxIndexToNotify(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGenericNotifyGiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxIndexToNotify = 1;
}

void vTaskGenericNotifyGiveFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGenericNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskGenericNotifyGiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

uint32_t ulTaskGenericNotifyTake(UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulTaskGenericNotifyTake);
  cmock_call_instance = (CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulTaskGenericNotifyTake_CallInstance);
  Mock.ulTaskGenericNotifyTake_CallInstance = CMock_Guts_MemNext(Mock.ulTaskGenericNotifyTake_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uxIndexToWaitOn)
  {
    UNITY_SET_DETAILS(CMockString_ulTaskGenericNotifyTake,CMockString_uxIndexToWaitOn);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxIndexToWaitOn), (void*)(&uxIndexToWaitOn), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xClearCountOnExit)
  {
    UNITY_SET_DETAILS(CMockString_ulTaskGenericNotifyTake,CMockString_xClearCountOnExit);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xClearCountOnExit), (void*)(&xClearCountOnExit), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_ulTaskGenericNotifyTake,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ulTaskGenericNotifyTake(CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE* cmock_call_instance, UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait);
void CMockExpectParameters_ulTaskGenericNotifyTake(CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE* cmock_call_instance, UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxIndexToWaitOn), (void*)(&uxIndexToWaitOn),
         sizeof(UBaseType_t[sizeof(uxIndexToWaitOn) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxIndexToWaitOn = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xClearCountOnExit), (void*)(&xClearCountOnExit),
         sizeof(BaseType_t[sizeof(xClearCountOnExit) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xClearCountOnExit = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void ulTaskGenericNotifyTake_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE));
  CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGenericNotifyTake_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGenericNotifyTake_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void ulTaskGenericNotifyTake_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE));
  CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGenericNotifyTake_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGenericNotifyTake_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_ulTaskGenericNotifyTake(cmock_call_instance, uxIndexToWaitOn, xClearCountOnExit, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ulTaskGenericNotifyTake_CMockIgnoreArg_uxIndexToWaitOn(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulTaskGenericNotifyTake_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxIndexToWaitOn = 1;
}

void ulTaskGenericNotifyTake_CMockIgnoreArg_xClearCountOnExit(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulTaskGenericNotifyTake_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xClearCountOnExit = 1;
}

void ulTaskGenericNotifyTake_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulTaskGenericNotifyTake_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

BaseType_t xTaskGenericNotifyStateClear(TaskHandle_t xTask, UBaseType_t uxIndexToClear)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGenericNotifyStateClear);
  cmock_call_instance = (CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGenericNotifyStateClear_CallInstance);
  Mock.xTaskGenericNotifyStateClear_CallInstance = CMock_Guts_MemNext(Mock.xTaskGenericNotifyStateClear_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyStateClear,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxIndexToClear)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyStateClear,CMockString_uxIndexToClear);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxIndexToClear), (void*)(&uxIndexToClear), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGenericNotifyStateClear(CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, UBaseType_t uxIndexToClear);
void CMockExpectParameters_xTaskGenericNotifyStateClear(CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, UBaseType_t uxIndexToClear)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxIndexToClear), (void*)(&uxIndexToClear),
         sizeof(UBaseType_t[sizeof(uxIndexToClear) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxIndexToClear = 0;
}

void xTaskGenericNotifyStateClear_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE));
  CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotifyStateClear_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotifyStateClear_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGenericNotifyStateClear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, UBaseType_t uxIndexToClear, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE));
  CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotifyStateClear_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotifyStateClear_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGenericNotifyStateClear(cmock_call_instance, xTask, uxIndexToClear);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskGenericNotifyStateClear_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyStateClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void xTaskGenericNotifyStateClear_CMockIgnoreArg_uxIndexToClear(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyStateClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGenericNotifyStateClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxIndexToClear = 1;
}

uint32_t ulTaskGenericNotifyValueClear(TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulTaskGenericNotifyValueClear);
  cmock_call_instance = (CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulTaskGenericNotifyValueClear_CallInstance);
  Mock.ulTaskGenericNotifyValueClear_CallInstance = CMock_Guts_MemNext(Mock.ulTaskGenericNotifyValueClear_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_ulTaskGenericNotifyValueClear,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxIndexToClear)
  {
    UNITY_SET_DETAILS(CMockString_ulTaskGenericNotifyValueClear,CMockString_uxIndexToClear);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxIndexToClear), (void*)(&uxIndexToClear), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ulBitsToClear)
  {
    UNITY_SET_DETAILS(CMockString_ulTaskGenericNotifyValueClear,CMockString_ulBitsToClear);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToClear, ulBitsToClear, cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ulTaskGenericNotifyValueClear(CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear);
void CMockExpectParameters_ulTaskGenericNotifyValueClear(CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxIndexToClear), (void*)(&uxIndexToClear),
         sizeof(UBaseType_t[sizeof(uxIndexToClear) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxIndexToClear = 0;
  cmock_call_instance->Expected_ulBitsToClear = ulBitsToClear;
  cmock_call_instance->IgnoreArg_ulBitsToClear = 0;
}

void ulTaskGenericNotifyValueClear_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE));
  CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGenericNotifyValueClear_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGenericNotifyValueClear_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void ulTaskGenericNotifyValueClear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE));
  CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskGenericNotifyValueClear_CallInstance = CMock_Guts_MemChain(Mock.ulTaskGenericNotifyValueClear_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_ulTaskGenericNotifyValueClear(cmock_call_instance, xTask, uxIndexToClear, ulBitsToClear);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ulTaskGenericNotifyValueClear_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulTaskGenericNotifyValueClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void ulTaskGenericNotifyValueClear_CMockIgnoreArg_uxIndexToClear(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulTaskGenericNotifyValueClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxIndexToClear = 1;
}

void ulTaskGenericNotifyValueClear_CMockIgnoreArg_ulBitsToClear(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskGenericNotifyValueClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulTaskGenericNotifyValueClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulBitsToClear = 1;
}

void vTaskSetTimeOutState(TimeOut_t* const pxTimeOut)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSetTimeOutState);
  cmock_call_instance = (CMOCK_vTaskSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSetTimeOutState_CallInstance);
  Mock.vTaskSetTimeOutState_CallInstance = CMock_Guts_MemNext(Mock.vTaskSetTimeOutState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTimeOut)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetTimeOutState,CMockString_pxTimeOut);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTimeOut), (void*)(pxTimeOut), sizeof(TimeOut_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxTimeOut_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTimeOut, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTimeOut, (const void*)cmock_call_instance->ReturnThruPtr_pxTimeOut_Val,
      cmock_call_instance->ReturnThruPtr_pxTimeOut_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSetTimeOutState(CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut);
void CMockExpectParameters_vTaskSetTimeOutState(CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut)
{
  cmock_call_instance->Expected_pxTimeOut = pxTimeOut;
  cmock_call_instance->IgnoreArg_pxTimeOut = 0;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Used = 0;
}

void vTaskSetTimeOutState_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetTimeOutState_CALL_INSTANCE));
  CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetTimeOutState_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetTimeOutState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskSetTimeOutState_CMockExpect(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetTimeOutState_CALL_INSTANCE));
  CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetTimeOutState_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetTimeOutState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskSetTimeOutState(cmock_call_instance, pxTimeOut);
}

void vTaskSetTimeOutState_CMockReturnMemThruPtr_pxTimeOut(UNITY_LINE_TYPE cmock_line, TimeOut_t const* pxTimeOut, size_t cmock_size)
{
  CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetTimeOutState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Val = pxTimeOut;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Size = cmock_size;
}

void vTaskSetTimeOutState_CMockIgnoreArg_pxTimeOut(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetTimeOutState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTimeOut = 1;
}

BaseType_t xTaskCheckForTimeOut(TimeOut_t* const pxTimeOut, TickType_t* const pxTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCheckForTimeOut);
  cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCheckForTimeOut_CallInstance);
  Mock.xTaskCheckForTimeOut_CallInstance = CMock_Guts_MemNext(Mock.xTaskCheckForTimeOut_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTimeOut)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCheckForTimeOut,CMockString_pxTimeOut);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTimeOut), (void*)(pxTimeOut), sizeof(TimeOut_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCheckForTimeOut,CMockString_pxTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTicksToWait), (void*)(pxTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxTimeOut_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTimeOut, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTimeOut, (const void*)cmock_call_instance->ReturnThruPtr_pxTimeOut_Val,
      cmock_call_instance->ReturnThruPtr_pxTimeOut_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxTicksToWait_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTicksToWait, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTicksToWait, (const void*)cmock_call_instance->ReturnThruPtr_pxTicksToWait_Val,
      cmock_call_instance->ReturnThruPtr_pxTicksToWait_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCheckForTimeOut(CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut, TickType_t* const pxTicksToWait);
void CMockExpectParameters_xTaskCheckForTimeOut(CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut, TickType_t* const pxTicksToWait)
{
  cmock_call_instance->Expected_pxTimeOut = pxTimeOut;
  cmock_call_instance->IgnoreArg_pxTimeOut = 0;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Used = 0;
  cmock_call_instance->Expected_pxTicksToWait = pxTicksToWait;
  cmock_call_instance->IgnoreArg_pxTicksToWait = 0;
  cmock_call_instance->ReturnThruPtr_pxTicksToWait_Used = 0;
}

void xTaskCheckForTimeOut_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE));
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCheckForTimeOut_CallInstance = CMock_Guts_MemChain(Mock.xTaskCheckForTimeOut_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCheckForTimeOut_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut, TickType_t* const pxTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE));
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCheckForTimeOut_CallInstance = CMock_Guts_MemChain(Mock.xTaskCheckForTimeOut_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCheckForTimeOut(cmock_call_instance, pxTimeOut, pxTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCheckForTimeOut_CMockReturnMemThruPtr_pxTimeOut(UNITY_LINE_TYPE cmock_line, TimeOut_t const* pxTimeOut, size_t cmock_size)
{
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCheckForTimeOut_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Val = pxTimeOut;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Size = cmock_size;
}

void xTaskCheckForTimeOut_CMockReturnMemThruPtr_pxTicksToWait(UNITY_LINE_TYPE cmock_line, TickType_t const* pxTicksToWait, size_t cmock_size)
{
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCheckForTimeOut_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTicksToWait_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTicksToWait_Val = pxTicksToWait;
  cmock_call_instance->ReturnThruPtr_pxTicksToWait_Size = cmock_size;
}

void xTaskCheckForTimeOut_CMockIgnoreArg_pxTimeOut(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCheckForTimeOut_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTimeOut = 1;
}

void xTaskCheckForTimeOut_CMockIgnoreArg_pxTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCheckForTimeOut_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTicksToWait = 1;
}

BaseType_t xTaskCatchUpTicks(TickType_t xTicksToCatchUp)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCatchUpTicks_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCatchUpTicks);
  cmock_call_instance = (CMOCK_xTaskCatchUpTicks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCatchUpTicks_CallInstance);
  Mock.xTaskCatchUpTicks_CallInstance = CMock_Guts_MemNext(Mock.xTaskCatchUpTicks_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTicksToCatchUp)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCatchUpTicks,CMockString_xTicksToCatchUp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToCatchUp), (void*)(&xTicksToCatchUp), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCatchUpTicks(CMOCK_xTaskCatchUpTicks_CALL_INSTANCE* cmock_call_instance, TickType_t xTicksToCatchUp);
void CMockExpectParameters_xTaskCatchUpTicks(CMOCK_xTaskCatchUpTicks_CALL_INSTANCE* cmock_call_instance, TickType_t xTicksToCatchUp)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToCatchUp), (void*)(&xTicksToCatchUp),
         sizeof(TickType_t[sizeof(xTicksToCatchUp) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToCatchUp = 0;
}

void xTaskCatchUpTicks_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCatchUpTicks_CALL_INSTANCE));
  CMOCK_xTaskCatchUpTicks_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCatchUpTicks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCatchUpTicks_CallInstance = CMock_Guts_MemChain(Mock.xTaskCatchUpTicks_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskCatchUpTicks_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t xTicksToCatchUp, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCatchUpTicks_CALL_INSTANCE));
  CMOCK_xTaskCatchUpTicks_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCatchUpTicks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCatchUpTicks_CallInstance = CMock_Guts_MemChain(Mock.xTaskCatchUpTicks_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskCatchUpTicks(cmock_call_instance, xTicksToCatchUp);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCatchUpTicks_CMockIgnoreArg_xTicksToCatchUp(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCatchUpTicks_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCatchUpTicks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCatchUpTicks_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToCatchUp = 1;
}

void vTaskResetState(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskResetState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskResetState);
  cmock_call_instance = (CMOCK_vTaskResetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskResetState_CallInstance);
  Mock.vTaskResetState_CallInstance = CMock_Guts_MemNext(Mock.vTaskResetState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskResetState_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskResetState_CALL_INSTANCE));
  CMOCK_vTaskResetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskResetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskResetState_CallInstance = CMock_Guts_MemChain(Mock.vTaskResetState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

BaseType_t xTaskIncrementTick(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskIncrementTick_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskIncrementTick);
  cmock_call_instance = (CMOCK_xTaskIncrementTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskIncrementTick_CallInstance);
  Mock.xTaskIncrementTick_CallInstance = CMock_Guts_MemNext(Mock.xTaskIncrementTick_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskIncrementTick_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskIncrementTick_CALL_INSTANCE));
  CMOCK_xTaskIncrementTick_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskIncrementTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskIncrementTick_CallInstance = CMock_Guts_MemChain(Mock.xTaskIncrementTick_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vTaskPlaceOnEventList(List_t* const pxEventList, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPlaceOnEventList);
  cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPlaceOnEventList_CallInstance);
  Mock.vTaskPlaceOnEventList_CallInstance = CMock_Guts_MemNext(Mock.vTaskPlaceOnEventList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxEventList)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventList,CMockString_pxEventList);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxEventList), (void*)(pxEventList), sizeof(List_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventList,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxEventList_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxEventList, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxEventList, (const void*)cmock_call_instance->ReturnThruPtr_pxEventList_Val,
      cmock_call_instance->ReturnThruPtr_pxEventList_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPlaceOnEventList(CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance, List_t* const pxEventList, const TickType_t xTicksToWait);
void CMockExpectParameters_vTaskPlaceOnEventList(CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance, List_t* const pxEventList, const TickType_t xTicksToWait)
{
  cmock_call_instance->Expected_pxEventList = pxEventList;
  cmock_call_instance->IgnoreArg_pxEventList = 0;
  cmock_call_instance->ReturnThruPtr_pxEventList_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void vTaskPlaceOnEventList_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskPlaceOnEventList_CMockExpect(UNITY_LINE_TYPE cmock_line, List_t* const pxEventList, const TickType_t xTicksToWait)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskPlaceOnEventList(cmock_call_instance, pxEventList, xTicksToWait);
}

void vTaskPlaceOnEventList_CMockReturnMemThruPtr_pxEventList(UNITY_LINE_TYPE cmock_line, List_t const* pxEventList, size_t cmock_size)
{
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxEventList_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxEventList_Val = pxEventList;
  cmock_call_instance->ReturnThruPtr_pxEventList_Size = cmock_size;
}

void vTaskPlaceOnEventList_CMockIgnoreArg_pxEventList(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxEventList = 1;
}

void vTaskPlaceOnEventList_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

void vTaskPlaceOnUnorderedEventList(List_t* pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPlaceOnUnorderedEventList);
  cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPlaceOnUnorderedEventList_CallInstance);
  Mock.vTaskPlaceOnUnorderedEventList_CallInstance = CMock_Guts_MemNext(Mock.vTaskPlaceOnUnorderedEventList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxEventList)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnUnorderedEventList,CMockString_pxEventList);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxEventList), (void*)(pxEventList), sizeof(List_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xItemValue)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnUnorderedEventList,CMockString_xItemValue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xItemValue), (void*)(&xItemValue), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnUnorderedEventList,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxEventList_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxEventList, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxEventList, (const void*)cmock_call_instance->ReturnThruPtr_pxEventList_Val,
      cmock_call_instance->ReturnThruPtr_pxEventList_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPlaceOnUnorderedEventList(CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance, List_t* pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait);
void CMockExpectParameters_vTaskPlaceOnUnorderedEventList(CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance, List_t* pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
  cmock_call_instance->Expected_pxEventList = pxEventList;
  cmock_call_instance->IgnoreArg_pxEventList = 0;
  cmock_call_instance->ReturnThruPtr_pxEventList_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xItemValue), (void*)(&xItemValue),
         sizeof(TickType_t[sizeof(xItemValue) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xItemValue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void vTaskPlaceOnUnorderedEventList_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnUnorderedEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnUnorderedEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskPlaceOnUnorderedEventList_CMockExpect(UNITY_LINE_TYPE cmock_line, List_t* pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnUnorderedEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnUnorderedEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskPlaceOnUnorderedEventList(cmock_call_instance, pxEventList, xItemValue, xTicksToWait);
}

void vTaskPlaceOnUnorderedEventList_CMockReturnMemThruPtr_pxEventList(UNITY_LINE_TYPE cmock_line, List_t const* pxEventList, size_t cmock_size)
{
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnUnorderedEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxEventList_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxEventList_Val = pxEventList;
  cmock_call_instance->ReturnThruPtr_pxEventList_Size = cmock_size;
}

void vTaskPlaceOnUnorderedEventList_CMockIgnoreArg_pxEventList(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnUnorderedEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxEventList = 1;
}

void vTaskPlaceOnUnorderedEventList_CMockIgnoreArg_xItemValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnUnorderedEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xItemValue = 1;
}

void vTaskPlaceOnUnorderedEventList_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnUnorderedEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

void vTaskPlaceOnEventListRestricted(List_t* const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPlaceOnEventListRestricted);
  cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPlaceOnEventListRestricted_CallInstance);
  Mock.vTaskPlaceOnEventListRestricted_CallInstance = CMock_Guts_MemNext(Mock.vTaskPlaceOnEventListRestricted_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxEventList)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventListRestricted,CMockString_pxEventList);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxEventList), (void*)(pxEventList), sizeof(List_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventListRestricted,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xWaitIndefinitely)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventListRestricted,CMockString_xWaitIndefinitely);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xWaitIndefinitely), (void*)(&xWaitIndefinitely), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxEventList_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxEventList, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxEventList, (const void*)cmock_call_instance->ReturnThruPtr_pxEventList_Val,
      cmock_call_instance->ReturnThruPtr_pxEventList_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPlaceOnEventListRestricted(CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance, List_t* const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely);
void CMockExpectParameters_vTaskPlaceOnEventListRestricted(CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance, List_t* const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  cmock_call_instance->Expected_pxEventList = pxEventList;
  cmock_call_instance->IgnoreArg_pxEventList = 0;
  cmock_call_instance->ReturnThruPtr_pxEventList_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xWaitIndefinitely), (void*)(&xWaitIndefinitely),
         sizeof(BaseType_t[sizeof(xWaitIndefinitely) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xWaitIndefinitely = 0;
}

void vTaskPlaceOnEventListRestricted_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnEventListRestricted_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnEventListRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskPlaceOnEventListRestricted_CMockExpect(UNITY_LINE_TYPE cmock_line, List_t* const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnEventListRestricted_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnEventListRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskPlaceOnEventListRestricted(cmock_call_instance, pxEventList, xTicksToWait, xWaitIndefinitely);
}

void vTaskPlaceOnEventListRestricted_CMockReturnMemThruPtr_pxEventList(UNITY_LINE_TYPE cmock_line, List_t const* pxEventList, size_t cmock_size)
{
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnEventListRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxEventList_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxEventList_Val = pxEventList;
  cmock_call_instance->ReturnThruPtr_pxEventList_Size = cmock_size;
}

void vTaskPlaceOnEventListRestricted_CMockIgnoreArg_pxEventList(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnEventListRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxEventList = 1;
}

void vTaskPlaceOnEventListRestricted_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnEventListRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

void vTaskPlaceOnEventListRestricted_CMockIgnoreArg_xWaitIndefinitely(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPlaceOnEventListRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xWaitIndefinitely = 1;
}

BaseType_t xTaskRemoveFromEventList(const List_t* const pxEventList)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskRemoveFromEventList);
  cmock_call_instance = (CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskRemoveFromEventList_CallInstance);
  Mock.xTaskRemoveFromEventList_CallInstance = CMock_Guts_MemNext(Mock.xTaskRemoveFromEventList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxEventList)
  {
    UNITY_SET_DETAILS(CMockString_xTaskRemoveFromEventList,CMockString_pxEventList);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxEventList), (void*)(pxEventList), sizeof(const List_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskRemoveFromEventList(CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance, const List_t* const pxEventList);
void CMockExpectParameters_xTaskRemoveFromEventList(CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance, const List_t* const pxEventList)
{
  cmock_call_instance->Expected_pxEventList = pxEventList;
  cmock_call_instance->IgnoreArg_pxEventList = 0;
}

void xTaskRemoveFromEventList_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE));
  CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskRemoveFromEventList_CallInstance = CMock_Guts_MemChain(Mock.xTaskRemoveFromEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskRemoveFromEventList_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const List_t* const pxEventList, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE));
  CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskRemoveFromEventList_CallInstance = CMock_Guts_MemChain(Mock.xTaskRemoveFromEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskRemoveFromEventList(cmock_call_instance, pxEventList);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskRemoveFromEventList_CMockIgnoreArg_pxEventList(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskRemoveFromEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxEventList = 1;
}

void vTaskRemoveFromUnorderedEventList(ListItem_t* pxEventListItem, const TickType_t xItemValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskRemoveFromUnorderedEventList);
  cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskRemoveFromUnorderedEventList_CallInstance);
  Mock.vTaskRemoveFromUnorderedEventList_CallInstance = CMock_Guts_MemNext(Mock.vTaskRemoveFromUnorderedEventList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxEventListItem)
  {
    UNITY_SET_DETAILS(CMockString_vTaskRemoveFromUnorderedEventList,CMockString_pxEventListItem);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxEventListItem), (void*)(pxEventListItem), sizeof(ListItem_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xItemValue)
  {
    UNITY_SET_DETAILS(CMockString_vTaskRemoveFromUnorderedEventList,CMockString_xItemValue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xItemValue), (void*)(&xItemValue), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxEventListItem_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxEventListItem, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxEventListItem, (const void*)cmock_call_instance->ReturnThruPtr_pxEventListItem_Val,
      cmock_call_instance->ReturnThruPtr_pxEventListItem_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskRemoveFromUnorderedEventList(CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance, ListItem_t* pxEventListItem, const TickType_t xItemValue);
void CMockExpectParameters_vTaskRemoveFromUnorderedEventList(CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance, ListItem_t* pxEventListItem, const TickType_t xItemValue)
{
  cmock_call_instance->Expected_pxEventListItem = pxEventListItem;
  cmock_call_instance->IgnoreArg_pxEventListItem = 0;
  cmock_call_instance->ReturnThruPtr_pxEventListItem_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xItemValue), (void*)(&xItemValue),
         sizeof(TickType_t[sizeof(xItemValue) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xItemValue = 0;
}

void vTaskRemoveFromUnorderedEventList_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE));
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskRemoveFromUnorderedEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskRemoveFromUnorderedEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskRemoveFromUnorderedEventList_CMockExpect(UNITY_LINE_TYPE cmock_line, ListItem_t* pxEventListItem, const TickType_t xItemValue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE));
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskRemoveFromUnorderedEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskRemoveFromUnorderedEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskRemoveFromUnorderedEventList(cmock_call_instance, pxEventListItem, xItemValue);
}

void vTaskRemoveFromUnorderedEventList_CMockReturnMemThruPtr_pxEventListItem(UNITY_LINE_TYPE cmock_line, ListItem_t const* pxEventListItem, size_t cmock_size)
{
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskRemoveFromUnorderedEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxEventListItem_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxEventListItem_Val = pxEventListItem;
  cmock_call_instance->ReturnThruPtr_pxEventListItem_Size = cmock_size;
}

void vTaskRemoveFromUnorderedEventList_CMockIgnoreArg_pxEventListItem(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskRemoveFromUnorderedEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxEventListItem = 1;
}

void vTaskRemoveFromUnorderedEventList_CMockIgnoreArg_xItemValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskRemoveFromUnorderedEventList_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xItemValue = 1;
}

void vTaskSwitchContext(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSwitchContext_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSwitchContext);
  cmock_call_instance = (CMOCK_vTaskSwitchContext_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSwitchContext_CallInstance);
  Mock.vTaskSwitchContext_CallInstance = CMock_Guts_MemNext(Mock.vTaskSwitchContext_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskSwitchContext_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSwitchContext_CALL_INSTANCE));
  CMOCK_vTaskSwitchContext_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSwitchContext_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSwitchContext_CallInstance = CMock_Guts_MemChain(Mock.vTaskSwitchContext_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

TickType_t uxTaskResetEventItemValue(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskResetEventItemValue);
  cmock_call_instance = (CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskResetEventItemValue_CallInstance);
  Mock.uxTaskResetEventItemValue_CallInstance = CMock_Guts_MemNext(Mock.uxTaskResetEventItemValue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void uxTaskResetEventItemValue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE));
  CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskResetEventItemValue_CallInstance = CMock_Guts_MemChain(Mock.uxTaskResetEventItemValue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

TaskHandle_t xTaskGetCurrentTaskHandle(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetCurrentTaskHandle);
  cmock_call_instance = (CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetCurrentTaskHandle_CallInstance);
  Mock.xTaskGetCurrentTaskHandle_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetCurrentTaskHandle_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetCurrentTaskHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE));
  CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetCurrentTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetCurrentTaskHandle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

TaskHandle_t xTaskGetCurrentTaskHandleForCore(BaseType_t xCoreID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetCurrentTaskHandleForCore);
  cmock_call_instance = (CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetCurrentTaskHandleForCore_CallInstance);
  Mock.xTaskGetCurrentTaskHandleForCore_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetCurrentTaskHandleForCore_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xCoreID)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetCurrentTaskHandleForCore,CMockString_xCoreID);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCoreID), (void*)(&xCoreID), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetCurrentTaskHandleForCore(CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE* cmock_call_instance, BaseType_t xCoreID);
void CMockExpectParameters_xTaskGetCurrentTaskHandleForCore(CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE* cmock_call_instance, BaseType_t xCoreID)
{
  memcpy((void*)(&cmock_call_instance->Expected_xCoreID), (void*)(&xCoreID),
         sizeof(BaseType_t[sizeof(xCoreID) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xCoreID = 0;
}

void xTaskGetCurrentTaskHandleForCore_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE));
  CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetCurrentTaskHandleForCore_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetCurrentTaskHandleForCore_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGetCurrentTaskHandleForCore_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t xCoreID, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE));
  CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetCurrentTaskHandleForCore_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetCurrentTaskHandleForCore_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGetCurrentTaskHandleForCore(cmock_call_instance, xCoreID);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskGetCurrentTaskHandleForCore_CMockIgnoreArg_xCoreID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetCurrentTaskHandleForCore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetCurrentTaskHandleForCore_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xCoreID = 1;
}

void vTaskMissedYield(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskMissedYield_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskMissedYield);
  cmock_call_instance = (CMOCK_vTaskMissedYield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskMissedYield_CallInstance);
  Mock.vTaskMissedYield_CallInstance = CMock_Guts_MemNext(Mock.vTaskMissedYield_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskMissedYield_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskMissedYield_CALL_INSTANCE));
  CMOCK_vTaskMissedYield_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskMissedYield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskMissedYield_CallInstance = CMock_Guts_MemChain(Mock.vTaskMissedYield_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

BaseType_t xTaskGetSchedulerState(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetSchedulerState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetSchedulerState);
  cmock_call_instance = (CMOCK_xTaskGetSchedulerState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetSchedulerState_CallInstance);
  Mock.xTaskGetSchedulerState_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetSchedulerState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetSchedulerState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetSchedulerState_CALL_INSTANCE));
  CMOCK_xTaskGetSchedulerState_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetSchedulerState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetSchedulerState_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetSchedulerState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskPriorityInherit);
  cmock_call_instance = (CMOCK_xTaskPriorityInherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskPriorityInherit_CallInstance);
  Mock.xTaskPriorityInherit_CallInstance = CMock_Guts_MemNext(Mock.xTaskPriorityInherit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxMutexHolder)
  {
    UNITY_SET_DETAILS(CMockString_xTaskPriorityInherit,CMockString_pxMutexHolder);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskPriorityInherit(CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance, TaskHandle_t const pxMutexHolder);
void CMockExpectParameters_xTaskPriorityInherit(CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance, TaskHandle_t const pxMutexHolder)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder),
         sizeof(TaskHandle_t[sizeof(pxMutexHolder) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxMutexHolder = 0;
}

void xTaskPriorityInherit_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskPriorityInherit_CALL_INSTANCE));
  CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskPriorityInherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskPriorityInherit_CallInstance = CMock_Guts_MemChain(Mock.xTaskPriorityInherit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskPriorityInherit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t const pxMutexHolder, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskPriorityInherit_CALL_INSTANCE));
  CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskPriorityInherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskPriorityInherit_CallInstance = CMock_Guts_MemChain(Mock.xTaskPriorityInherit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskPriorityInherit(cmock_call_instance, pxMutexHolder);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskPriorityInherit_CMockIgnoreArg_pxMutexHolder(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskPriorityInherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskPriorityInherit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxMutexHolder = 1;
}

BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskPriorityDisinherit);
  cmock_call_instance = (CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskPriorityDisinherit_CallInstance);
  Mock.xTaskPriorityDisinherit_CallInstance = CMock_Guts_MemNext(Mock.xTaskPriorityDisinherit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxMutexHolder)
  {
    UNITY_SET_DETAILS(CMockString_xTaskPriorityDisinherit,CMockString_pxMutexHolder);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskPriorityDisinherit(CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance, TaskHandle_t const pxMutexHolder);
void CMockExpectParameters_xTaskPriorityDisinherit(CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance, TaskHandle_t const pxMutexHolder)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder),
         sizeof(TaskHandle_t[sizeof(pxMutexHolder) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxMutexHolder = 0;
}

void xTaskPriorityDisinherit_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE));
  CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskPriorityDisinherit_CallInstance = CMock_Guts_MemChain(Mock.xTaskPriorityDisinherit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskPriorityDisinherit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t const pxMutexHolder, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE));
  CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskPriorityDisinherit_CallInstance = CMock_Guts_MemChain(Mock.xTaskPriorityDisinherit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskPriorityDisinherit(cmock_call_instance, pxMutexHolder);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskPriorityDisinherit_CMockIgnoreArg_pxMutexHolder(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskPriorityDisinherit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxMutexHolder = 1;
}

void vTaskPriorityDisinheritAfterTimeout(TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPriorityDisinheritAfterTimeout);
  cmock_call_instance = (CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance);
  Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance = CMock_Guts_MemNext(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxMutexHolder)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPriorityDisinheritAfterTimeout,CMockString_pxMutexHolder);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxHighestPriorityWaitingTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskPriorityDisinheritAfterTimeout,CMockString_uxHighestPriorityWaitingTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxHighestPriorityWaitingTask), (void*)(&uxHighestPriorityWaitingTask), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPriorityDisinheritAfterTimeout(CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance, TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask);
void CMockExpectParameters_vTaskPriorityDisinheritAfterTimeout(CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance, TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder),
         sizeof(TaskHandle_t[sizeof(pxMutexHolder) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxMutexHolder = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxHighestPriorityWaitingTask), (void*)(&uxHighestPriorityWaitingTask),
         sizeof(UBaseType_t[sizeof(uxHighestPriorityWaitingTask) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxHighestPriorityWaitingTask = 0;
}

void vTaskPriorityDisinheritAfterTimeout_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE));
  CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance = CMock_Guts_MemChain(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskPriorityDisinheritAfterTimeout_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE));
  CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance = CMock_Guts_MemChain(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskPriorityDisinheritAfterTimeout(cmock_call_instance, pxMutexHolder, uxHighestPriorityWaitingTask);
}

void vTaskPriorityDisinheritAfterTimeout_CMockIgnoreArg_pxMutexHolder(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxMutexHolder = 1;
}

void vTaskPriorityDisinheritAfterTimeout_CMockIgnoreArg_uxHighestPriorityWaitingTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxHighestPriorityWaitingTask = 1;
}

UBaseType_t uxTaskGetTaskNumber(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetTaskNumber);
  cmock_call_instance = (CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetTaskNumber_CallInstance);
  Mock.uxTaskGetTaskNumber_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetTaskNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetTaskNumber,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskGetTaskNumber(CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask);
void CMockExpectParameters_uxTaskGetTaskNumber(CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void uxTaskGetTaskNumber_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE));
  CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetTaskNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetTaskNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTaskGetTaskNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE));
  CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetTaskNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetTaskNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTaskGetTaskNumber(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTaskGetTaskNumber_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTaskGetTaskNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskSetTaskNumber(TaskHandle_t xTask, const UBaseType_t uxHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSetTaskNumber);
  cmock_call_instance = (CMOCK_vTaskSetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSetTaskNumber_CallInstance);
  Mock.vTaskSetTaskNumber_CallInstance = CMock_Guts_MemNext(Mock.vTaskSetTaskNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetTaskNumber,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxHandle)
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetTaskNumber,CMockString_uxHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxHandle), (void*)(&uxHandle), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSetTaskNumber(CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, const UBaseType_t uxHandle);
void CMockExpectParameters_vTaskSetTaskNumber(CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, const UBaseType_t uxHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxHandle), (void*)(&uxHandle),
         sizeof(UBaseType_t[sizeof(uxHandle) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxHandle = 0;
}

void vTaskSetTaskNumber_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetTaskNumber_CALL_INSTANCE));
  CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetTaskNumber_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetTaskNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskSetTaskNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, const UBaseType_t uxHandle)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetTaskNumber_CALL_INSTANCE));
  CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetTaskNumber_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetTaskNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskSetTaskNumber(cmock_call_instance, xTask, uxHandle);
}

void vTaskSetTaskNumber_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetTaskNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vTaskSetTaskNumber_CMockIgnoreArg_uxHandle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskSetTaskNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxHandle = 1;
}

void vTaskStepTick(TickType_t xTicksToJump)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskStepTick);
  cmock_call_instance = (CMOCK_vTaskStepTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskStepTick_CallInstance);
  Mock.vTaskStepTick_CallInstance = CMock_Guts_MemNext(Mock.vTaskStepTick_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTicksToJump)
  {
    UNITY_SET_DETAILS(CMockString_vTaskStepTick,CMockString_xTicksToJump);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToJump), (void*)(&xTicksToJump), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskStepTick(CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance, TickType_t xTicksToJump);
void CMockExpectParameters_vTaskStepTick(CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance, TickType_t xTicksToJump)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToJump), (void*)(&xTicksToJump),
         sizeof(TickType_t[sizeof(xTicksToJump) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToJump = 0;
}

void vTaskStepTick_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskStepTick_CALL_INSTANCE));
  CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskStepTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskStepTick_CallInstance = CMock_Guts_MemChain(Mock.vTaskStepTick_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskStepTick_CMockExpect(UNITY_LINE_TYPE cmock_line, TickType_t xTicksToJump)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskStepTick_CALL_INSTANCE));
  CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskStepTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskStepTick_CallInstance = CMock_Guts_MemChain(Mock.vTaskStepTick_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskStepTick(cmock_call_instance, xTicksToJump);
}

void vTaskStepTick_CMockIgnoreArg_xTicksToJump(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskStepTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskStepTick_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToJump = 1;
}

eSleepModeStatus eTaskConfirmSleepModeStatus(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_eTaskConfirmSleepModeStatus);
  cmock_call_instance = (CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.eTaskConfirmSleepModeStatus_CallInstance);
  Mock.eTaskConfirmSleepModeStatus_CallInstance = CMock_Guts_MemNext(Mock.eTaskConfirmSleepModeStatus_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void eTaskConfirmSleepModeStatus_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eSleepModeStatus cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE));
  CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eTaskConfirmSleepModeStatus_CallInstance = CMock_Guts_MemChain(Mock.eTaskConfirmSleepModeStatus_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eSleepModeStatus[sizeof(cmock_to_return) == sizeof(eSleepModeStatus) ? 1 : -1])); /* add eSleepModeStatus to :treat_as_array if this causes an error */
}

TaskHandle_t pvTaskIncrementMutexHeldCount(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pvTaskIncrementMutexHeldCount);
  cmock_call_instance = (CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pvTaskIncrementMutexHeldCount_CallInstance);
  Mock.pvTaskIncrementMutexHeldCount_CallInstance = CMock_Guts_MemNext(Mock.pvTaskIncrementMutexHeldCount_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void pvTaskIncrementMutexHeldCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE));
  CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTaskIncrementMutexHeldCount_CallInstance = CMock_Guts_MemChain(Mock.pvTaskIncrementMutexHeldCount_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void vTaskInternalSetTimeOutState(TimeOut_t* const pxTimeOut)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskInternalSetTimeOutState);
  cmock_call_instance = (CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskInternalSetTimeOutState_CallInstance);
  Mock.vTaskInternalSetTimeOutState_CallInstance = CMock_Guts_MemNext(Mock.vTaskInternalSetTimeOutState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTimeOut)
  {
    UNITY_SET_DETAILS(CMockString_vTaskInternalSetTimeOutState,CMockString_pxTimeOut);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTimeOut), (void*)(pxTimeOut), sizeof(TimeOut_t), cmock_line, CMockStringMismatch);
  }
  }
  if (cmock_call_instance->ReturnThruPtr_pxTimeOut_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTimeOut, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTimeOut, (const void*)cmock_call_instance->ReturnThruPtr_pxTimeOut_Val,
      cmock_call_instance->ReturnThruPtr_pxTimeOut_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskInternalSetTimeOutState(CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut);
void CMockExpectParameters_vTaskInternalSetTimeOutState(CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut)
{
  cmock_call_instance->Expected_pxTimeOut = pxTimeOut;
  cmock_call_instance->IgnoreArg_pxTimeOut = 0;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Used = 0;
}

void vTaskInternalSetTimeOutState_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE));
  CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskInternalSetTimeOutState_CallInstance = CMock_Guts_MemChain(Mock.vTaskInternalSetTimeOutState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskInternalSetTimeOutState_CMockExpect(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE));
  CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskInternalSetTimeOutState_CallInstance = CMock_Guts_MemChain(Mock.vTaskInternalSetTimeOutState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskInternalSetTimeOutState(cmock_call_instance, pxTimeOut);
}

void vTaskInternalSetTimeOutState_CMockReturnMemThruPtr_pxTimeOut(UNITY_LINE_TYPE cmock_line, TimeOut_t const* pxTimeOut, size_t cmock_size)
{
  CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskInternalSetTimeOutState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Val = pxTimeOut;
  cmock_call_instance->ReturnThruPtr_pxTimeOut_Size = cmock_size;
}

void vTaskInternalSetTimeOutState_CMockIgnoreArg_pxTimeOut(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskInternalSetTimeOutState_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTimeOut = 1;
}

void vTaskYieldWithinAPI(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskYieldWithinAPI_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskYieldWithinAPI);
  cmock_call_instance = (CMOCK_vTaskYieldWithinAPI_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskYieldWithinAPI_CallInstance);
  Mock.vTaskYieldWithinAPI_CallInstance = CMock_Guts_MemNext(Mock.vTaskYieldWithinAPI_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskYieldWithinAPI_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskYieldWithinAPI_CALL_INSTANCE));
  CMOCK_vTaskYieldWithinAPI_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskYieldWithinAPI_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskYieldWithinAPI_CallInstance = CMock_Guts_MemChain(Mock.vTaskYieldWithinAPI_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vTaskEnterCritical(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskEnterCritical_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskEnterCritical);
  cmock_call_instance = (CMOCK_vTaskEnterCritical_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskEnterCritical_CallInstance);
  Mock.vTaskEnterCritical_CallInstance = CMock_Guts_MemNext(Mock.vTaskEnterCritical_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskEnterCritical_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskEnterCritical_CALL_INSTANCE));
  CMOCK_vTaskEnterCritical_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskEnterCritical_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskEnterCritical_CallInstance = CMock_Guts_MemChain(Mock.vTaskEnterCritical_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vTaskExitCritical(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskExitCritical_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskExitCritical);
  cmock_call_instance = (CMOCK_vTaskExitCritical_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskExitCritical_CallInstance);
  Mock.vTaskExitCritical_CallInstance = CMock_Guts_MemNext(Mock.vTaskExitCritical_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskExitCritical_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskExitCritical_CALL_INSTANCE));
  CMOCK_vTaskExitCritical_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskExitCritical_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskExitCritical_CallInstance = CMock_Guts_MemChain(Mock.vTaskExitCritical_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

UBaseType_t vTaskEnterCriticalFromISR(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskEnterCriticalFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskEnterCriticalFromISR);
  cmock_call_instance = (CMOCK_vTaskEnterCriticalFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskEnterCriticalFromISR_CallInstance);
  Mock.vTaskEnterCriticalFromISR_CallInstance = CMock_Guts_MemNext(Mock.vTaskEnterCriticalFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vTaskEnterCriticalFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskEnterCriticalFromISR_CALL_INSTANCE));
  CMOCK_vTaskEnterCriticalFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskEnterCriticalFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskEnterCriticalFromISR_CallInstance = CMock_Guts_MemChain(Mock.vTaskEnterCriticalFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vTaskExitCriticalFromISR(UBaseType_t uxSavedInterruptStatus)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskExitCriticalFromISR);
  cmock_call_instance = (CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskExitCriticalFromISR_CallInstance);
  Mock.vTaskExitCriticalFromISR_CallInstance = CMock_Guts_MemNext(Mock.vTaskExitCriticalFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uxSavedInterruptStatus)
  {
    UNITY_SET_DETAILS(CMockString_vTaskExitCriticalFromISR,CMockString_uxSavedInterruptStatus);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxSavedInterruptStatus), (void*)(&uxSavedInterruptStatus), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskExitCriticalFromISR(CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE* cmock_call_instance, UBaseType_t uxSavedInterruptStatus);
void CMockExpectParameters_vTaskExitCriticalFromISR(CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE* cmock_call_instance, UBaseType_t uxSavedInterruptStatus)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxSavedInterruptStatus), (void*)(&uxSavedInterruptStatus),
         sizeof(UBaseType_t[sizeof(uxSavedInterruptStatus) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxSavedInterruptStatus = 0;
}

void vTaskExitCriticalFromISR_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE));
  CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskExitCriticalFromISR_CallInstance = CMock_Guts_MemChain(Mock.vTaskExitCriticalFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTaskExitCriticalFromISR_CMockExpect(UNITY_LINE_TYPE cmock_line, UBaseType_t uxSavedInterruptStatus)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE));
  CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskExitCriticalFromISR_CallInstance = CMock_Guts_MemChain(Mock.vTaskExitCriticalFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTaskExitCriticalFromISR(cmock_call_instance, uxSavedInterruptStatus);
}

void vTaskExitCriticalFromISR_CMockIgnoreArg_uxSavedInterruptStatus(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskExitCriticalFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskExitCriticalFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxSavedInterruptStatus = 1;
}

xMPU_SETTINGS* xTaskGetMPUSettings(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetMPUSettings_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetMPUSettings);
  cmock_call_instance = (CMOCK_xTaskGetMPUSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetMPUSettings_CallInstance);
  Mock.xTaskGetMPUSettings_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetMPUSettings_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetMPUSettings,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetMPUSettings(CMOCK_xTaskGetMPUSettings_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask);
void CMockExpectParameters_xTaskGetMPUSettings(CMOCK_xTaskGetMPUSettings_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTask = 0;
}

void xTaskGetMPUSettings_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, xMPU_SETTINGS* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetMPUSettings_CALL_INSTANCE));
  CMOCK_xTaskGetMPUSettings_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetMPUSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetMPUSettings_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetMPUSettings_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTaskGetMPUSettings_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, xMPU_SETTINGS* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetMPUSettings_CALL_INSTANCE));
  CMOCK_xTaskGetMPUSettings_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetMPUSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetMPUSettings_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetMPUSettings_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTaskGetMPUSettings(cmock_call_instance, xTask);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTaskGetMPUSettings_CMockIgnoreArg_xTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskGetMPUSettings_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetMPUSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskGetMPUSettings_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTask = 1;
}

void vGrantAccessToKernelObject(TaskHandle_t xExternalTaskHandle, int32_t lExternalKernelObjectHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGrantAccessToKernelObject);
  cmock_call_instance = (CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGrantAccessToKernelObject_CallInstance);
  Mock.vGrantAccessToKernelObject_CallInstance = CMock_Guts_MemNext(Mock.vGrantAccessToKernelObject_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xExternalTaskHandle)
  {
    UNITY_SET_DETAILS(CMockString_vGrantAccessToKernelObject,CMockString_xExternalTaskHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xExternalTaskHandle), (void*)(&xExternalTaskHandle), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_lExternalKernelObjectHandle)
  {
    UNITY_SET_DETAILS(CMockString_vGrantAccessToKernelObject,CMockString_lExternalKernelObjectHandle);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_lExternalKernelObjectHandle, lExternalKernelObjectHandle, cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vGrantAccessToKernelObject(CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xExternalTaskHandle, int32_t lExternalKernelObjectHandle);
void CMockExpectParameters_vGrantAccessToKernelObject(CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xExternalTaskHandle, int32_t lExternalKernelObjectHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_xExternalTaskHandle), (void*)(&xExternalTaskHandle),
         sizeof(TaskHandle_t[sizeof(xExternalTaskHandle) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xExternalTaskHandle = 0;
  cmock_call_instance->Expected_lExternalKernelObjectHandle = lExternalKernelObjectHandle;
  cmock_call_instance->IgnoreArg_lExternalKernelObjectHandle = 0;
}

void vGrantAccessToKernelObject_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE));
  CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGrantAccessToKernelObject_CallInstance = CMock_Guts_MemChain(Mock.vGrantAccessToKernelObject_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vGrantAccessToKernelObject_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xExternalTaskHandle, int32_t lExternalKernelObjectHandle)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE));
  CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGrantAccessToKernelObject_CallInstance = CMock_Guts_MemChain(Mock.vGrantAccessToKernelObject_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGrantAccessToKernelObject(cmock_call_instance, xExternalTaskHandle, lExternalKernelObjectHandle);
}

void vGrantAccessToKernelObject_CMockIgnoreArg_xExternalTaskHandle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGrantAccessToKernelObject_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xExternalTaskHandle = 1;
}

void vGrantAccessToKernelObject_CMockIgnoreArg_lExternalKernelObjectHandle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGrantAccessToKernelObject_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_lExternalKernelObjectHandle = 1;
}

void vRevokeAccessToKernelObject(TaskHandle_t xExternalTaskHandle, int32_t lExternalKernelObjectHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vRevokeAccessToKernelObject);
  cmock_call_instance = (CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vRevokeAccessToKernelObject_CallInstance);
  Mock.vRevokeAccessToKernelObject_CallInstance = CMock_Guts_MemNext(Mock.vRevokeAccessToKernelObject_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xExternalTaskHandle)
  {
    UNITY_SET_DETAILS(CMockString_vRevokeAccessToKernelObject,CMockString_xExternalTaskHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xExternalTaskHandle), (void*)(&xExternalTaskHandle), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_lExternalKernelObjectHandle)
  {
    UNITY_SET_DETAILS(CMockString_vRevokeAccessToKernelObject,CMockString_lExternalKernelObjectHandle);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_lExternalKernelObjectHandle, lExternalKernelObjectHandle, cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vRevokeAccessToKernelObject(CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xExternalTaskHandle, int32_t lExternalKernelObjectHandle);
void CMockExpectParameters_vRevokeAccessToKernelObject(CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xExternalTaskHandle, int32_t lExternalKernelObjectHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_xExternalTaskHandle), (void*)(&xExternalTaskHandle),
         sizeof(TaskHandle_t[sizeof(xExternalTaskHandle) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xExternalTaskHandle = 0;
  cmock_call_instance->Expected_lExternalKernelObjectHandle = lExternalKernelObjectHandle;
  cmock_call_instance->IgnoreArg_lExternalKernelObjectHandle = 0;
}

void vRevokeAccessToKernelObject_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE));
  CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vRevokeAccessToKernelObject_CallInstance = CMock_Guts_MemChain(Mock.vRevokeAccessToKernelObject_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vRevokeAccessToKernelObject_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xExternalTaskHandle, int32_t lExternalKernelObjectHandle)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE));
  CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vRevokeAccessToKernelObject_CallInstance = CMock_Guts_MemChain(Mock.vRevokeAccessToKernelObject_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vRevokeAccessToKernelObject(cmock_call_instance, xExternalTaskHandle, lExternalKernelObjectHandle);
}

void vRevokeAccessToKernelObject_CMockIgnoreArg_xExternalTaskHandle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vRevokeAccessToKernelObject_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xExternalTaskHandle = 1;
}

void vRevokeAccessToKernelObject_CMockIgnoreArg_lExternalKernelObjectHandle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vRevokeAccessToKernelObject_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_lExternalKernelObjectHandle = 1;
}

void vPortGrantAccessToKernelObject(TaskHandle_t xInternalTaskHandle, int32_t lInternalIndexOfKernelObject)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vPortGrantAccessToKernelObject);
  cmock_call_instance = (CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vPortGrantAccessToKernelObject_CallInstance);
  Mock.vPortGrantAccessToKernelObject_CallInstance = CMock_Guts_MemNext(Mock.vPortGrantAccessToKernelObject_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xInternalTaskHandle)
  {
    UNITY_SET_DETAILS(CMockString_vPortGrantAccessToKernelObject,CMockString_xInternalTaskHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xInternalTaskHandle), (void*)(&xInternalTaskHandle), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_lInternalIndexOfKernelObject)
  {
    UNITY_SET_DETAILS(CMockString_vPortGrantAccessToKernelObject,CMockString_lInternalIndexOfKernelObject);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_lInternalIndexOfKernelObject, lInternalIndexOfKernelObject, cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vPortGrantAccessToKernelObject(CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xInternalTaskHandle, int32_t lInternalIndexOfKernelObject);
void CMockExpectParameters_vPortGrantAccessToKernelObject(CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xInternalTaskHandle, int32_t lInternalIndexOfKernelObject)
{
  memcpy((void*)(&cmock_call_instance->Expected_xInternalTaskHandle), (void*)(&xInternalTaskHandle),
         sizeof(TaskHandle_t[sizeof(xInternalTaskHandle) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xInternalTaskHandle = 0;
  cmock_call_instance->Expected_lInternalIndexOfKernelObject = lInternalIndexOfKernelObject;
  cmock_call_instance->IgnoreArg_lInternalIndexOfKernelObject = 0;
}

void vPortGrantAccessToKernelObject_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE));
  CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vPortGrantAccessToKernelObject_CallInstance = CMock_Guts_MemChain(Mock.vPortGrantAccessToKernelObject_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vPortGrantAccessToKernelObject_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xInternalTaskHandle, int32_t lInternalIndexOfKernelObject)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE));
  CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vPortGrantAccessToKernelObject_CallInstance = CMock_Guts_MemChain(Mock.vPortGrantAccessToKernelObject_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vPortGrantAccessToKernelObject(cmock_call_instance, xInternalTaskHandle, lInternalIndexOfKernelObject);
}

void vPortGrantAccessToKernelObject_CMockIgnoreArg_xInternalTaskHandle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vPortGrantAccessToKernelObject_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xInternalTaskHandle = 1;
}

void vPortGrantAccessToKernelObject_CMockIgnoreArg_lInternalIndexOfKernelObject(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vPortGrantAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vPortGrantAccessToKernelObject_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_lInternalIndexOfKernelObject = 1;
}

void vPortRevokeAccessToKernelObject(TaskHandle_t xInternalTaskHandle, int32_t lInternalIndexOfKernelObject)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vPortRevokeAccessToKernelObject);
  cmock_call_instance = (CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vPortRevokeAccessToKernelObject_CallInstance);
  Mock.vPortRevokeAccessToKernelObject_CallInstance = CMock_Guts_MemNext(Mock.vPortRevokeAccessToKernelObject_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xInternalTaskHandle)
  {
    UNITY_SET_DETAILS(CMockString_vPortRevokeAccessToKernelObject,CMockString_xInternalTaskHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xInternalTaskHandle), (void*)(&xInternalTaskHandle), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_lInternalIndexOfKernelObject)
  {
    UNITY_SET_DETAILS(CMockString_vPortRevokeAccessToKernelObject,CMockString_lInternalIndexOfKernelObject);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_lInternalIndexOfKernelObject, lInternalIndexOfKernelObject, cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vPortRevokeAccessToKernelObject(CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xInternalTaskHandle, int32_t lInternalIndexOfKernelObject);
void CMockExpectParameters_vPortRevokeAccessToKernelObject(CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xInternalTaskHandle, int32_t lInternalIndexOfKernelObject)
{
  memcpy((void*)(&cmock_call_instance->Expected_xInternalTaskHandle), (void*)(&xInternalTaskHandle),
         sizeof(TaskHandle_t[sizeof(xInternalTaskHandle) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xInternalTaskHandle = 0;
  cmock_call_instance->Expected_lInternalIndexOfKernelObject = lInternalIndexOfKernelObject;
  cmock_call_instance->IgnoreArg_lInternalIndexOfKernelObject = 0;
}

void vPortRevokeAccessToKernelObject_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE));
  CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vPortRevokeAccessToKernelObject_CallInstance = CMock_Guts_MemChain(Mock.vPortRevokeAccessToKernelObject_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vPortRevokeAccessToKernelObject_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xInternalTaskHandle, int32_t lInternalIndexOfKernelObject)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE));
  CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vPortRevokeAccessToKernelObject_CallInstance = CMock_Guts_MemChain(Mock.vPortRevokeAccessToKernelObject_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vPortRevokeAccessToKernelObject(cmock_call_instance, xInternalTaskHandle, lInternalIndexOfKernelObject);
}

void vPortRevokeAccessToKernelObject_CMockIgnoreArg_xInternalTaskHandle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vPortRevokeAccessToKernelObject_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xInternalTaskHandle = 1;
}

void vPortRevokeAccessToKernelObject_CMockIgnoreArg_lInternalIndexOfKernelObject(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE* cmock_call_instance = (CMOCK_vPortRevokeAccessToKernelObject_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vPortRevokeAccessToKernelObject_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_lInternalIndexOfKernelObject = 1;
}

